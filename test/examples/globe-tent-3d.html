<!DOCTYPE html>
<html lang="en">
<head>
    <title>Add a custom layer with tiles to a globe</title>
    <meta property="og:description" content="Use custom layer to display arbitrary tiles drawn with a custom WebGL shader on a globe." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
        #project {
            display: block;
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translate(-50%);
            width: 50%;
            height: 40px;
            padding: 10px;
            border: none;
            border-radius: 3px;
            font-size: 12px;
            text-align: center;
            color: #fff;
            background: #ee8a65;
        }
    </style>
</head>
<body>
<div id="map"></div>
<br />
<button id="project">Toggle projection</button>
<script>
    const map = new maplibregl.Map({
        container: 'map',
        style: 'https://demotiles.maplibre.org/style.json',
        zoom: 2,
        center: [7.5, 58],
        antialias: false,
    });

    map.on('style.load', () => {
        map.setProjection({
            type: 'globe', // Set projection to globe
        });
    });

    document.getElementById('project').addEventListener('click', () => {
        // Toggle projection
        const currentProjection = map.getProjection();
        map.setProjection({
            type: currentProjection.type === 'globe' ? 'mercator' : 'globe',
        });
    });
    class Tent3DGlobe {
        id;
        type;
        renderingMode;

        vertexBuffer;
        indexBuffer;
        shaderMap = new Map();

        constructor() {
            this.id = 'tent-3d-globe';
            this.type = 'custom';
            this.renderingMode = '3d';
        }

        getShader(gl, shaderDescription) {
            if (this.shaderMap.has(shaderDescription.variantName)) {
                return this.shaderMap.get(shaderDescription.variantName);
            }

            const vertexSource = `#version 300 es
            // Inject MapLibre projection code
            ${shaderDescription.vertexShaderPrelude}
            ${shaderDescription.define}
            
            in vec3 a_pos;

            void main() {
                gl_Position = projectTileFor3D(a_pos.xy, a_pos.z);
            }`;

            // create GLSL source for fragment shader
            const fragmentSource = `#version 300 es
            uniform mediump vec4 u_color;
            out highp vec4 fragColor;
            void main() {
                fragColor = u_color;
            }`;

            // create a vertex shader
            const vertexShader = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vertexShader, vertexSource);
            gl.compileShader(vertexShader);

            // create a fragment shader
            const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fragmentShader, fragmentSource);
            gl.compileShader(fragmentShader);

            // link the two shaders into a WebGL program
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);

            const result = {
                program,
                aPos: gl.getAttribLocation(program, 'a_pos'),
            };

            this.shaderMap.set(shaderDescription.variantName, result);

            return result;
        }

        onAdd (map, gl) {
            const x = 0.5 - 0.015;
            const y = 0.5 - 0.01;
            const z = 500_000;
            const d = 0.01;

            const vertexArray = new Float32Array([
                x, y, 0,
                x + d, y, 0,
                x, y + d, z,
                x + d, y + d, z,
                x, y + d + d, 0,
                x + d, y + d + d, 0]);
            const indexArray = new Uint16Array([
                0, 2, 1,
                1, 2, 3,
                2, 4, 3,
                3, 4, 5
            ]);

            this.vertexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertexArray, gl.STATIC_DRAW);
            this.indexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indexArray, gl.STATIC_DRAW);
        }

        render (gl, args) {
            const shader = this.getShader(gl, args.shaderData);
            gl.useProgram(shader.program);
            gl.uniformMatrix4fv(
                gl.getUniformLocation(shader.program, 'u_projection_fallback_matrix'),
                false,
                args.defaultProjectionData.fallbackMatrix
            );
            gl.uniformMatrix4fv(
                gl.getUniformLocation(shader.program, 'u_projection_matrix'),
                false,
                args.defaultProjectionData.mainMatrix
            );
            gl.uniform4f(
                gl.getUniformLocation(shader.program, 'u_projection_tile_mercator_coords'),
                ...args.defaultProjectionData.tileMercatorCoords
            );
            gl.uniform4f(
                gl.getUniformLocation(shader.program, 'u_projection_clipping_plane'),
                ...args.defaultProjectionData.clippingPlane
            );
            gl.uniform1f(
                gl.getUniformLocation(shader.program, 'u_projection_transition'),
                args.defaultProjectionData.projectionTransition
            );

            gl.enable(gl.CULL_FACE);
            gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
            gl.enableVertexAttribArray(shader.aPos);
            gl.vertexAttribPointer(shader.aPos, 3, gl.FLOAT, false, 0, 0);
            for (let i = 0; i < 2; i++) {
                gl.uniform4f(
                    gl.getUniformLocation(shader.program, 'u_color'),
                    i === 0 ? 1 : 0.25, 0, 0, 1
                );
                gl.cullFace(i === 0 ? gl.BACK : gl.FRONT);
                gl.drawElements(gl.TRIANGLES, 12, gl.UNSIGNED_SHORT, 0);
            }
        }
    }

    // add the custom style layer to the map
    map.on('load', () => {
        map.addLayer(new Tent3DGlobe());
    });
</script>
</body>
</html>
