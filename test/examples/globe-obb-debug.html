<!DOCTYPE html>
<html lang="en">
    <head>
        <title>Add a simple custom layer on a globe</title>
        <meta
            property="og:description"
            content="Use a custom layer to draw simple WebGL content on a globe."
        />
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="stylesheet" href="../../dist/maplibre-gl.css" />
        <script src="../../dist/maplibre-gl-dev.js"></script>
        <style>
            body {
                margin: 0;
                padding: 0;
            }
            html,
            body,
            #map {
                height: 100%;
            }
            #project {
                display: block;
                position: absolute;
                top: 20px;
                left: 50%;
                transform: translate(-50%);
                width: 50%;
                height: 40px;
                padding: 10px;
                border: none;
                border-radius: 3px;
                font-size: 12px;
                text-align: center;
                color: #fff;
                background: #ee8a65;
            }
        </style>
    </head>
    <body>
        <div id="map"></div>
        <br />
        <button id="project">Toggle projection</button>
        <script>
            const map = new maplibregl.Map({
                container: "map",
                style: "https://demotiles.maplibre.org/style.json",
                zoom: 3,
                center: [7.5, 58],
            });

            map.on("style.load", () => {
                map.setProjection({
                    type: "globe", // Set projection to globe
                });
            });

            document.getElementById("project").addEventListener("click", () => {
                // Toggle projection
                const currentProjection = map.getProjection();
                map.setProjection({
                    type:
                        currentProjection.type === "globe"
                            ? "mercator"
                            : "globe",
                });
            });

            const boxContext = {
                hoveredTile: undefined,
                hoveredObb: undefined,
            };

            document.getElementById("map").onmousemove = (e) => {
                const unproj = map.unproject([e.clientX, e.clientY]);
                const mercator =
                    maplibregl.MercatorCoordinate.fromLngLat(unproj);
                const cache = map.style.sourceCaches["maplibre"];
                if (!cache) {
                    return;
                }
                const tiles = cache.getVisibleCoordinates(false);
                let targetTile = undefined;
                for (const t of tiles) {
                    const scale = 1 << t.canonical.z;
                    const x = mercator.x * scale;
                    const y = mercator.y * scale;
                    if (
                        x >= t.canonical.x &&
                        y >= t.canonical.y &&
                        x <= t.canonical.x + 1 &&
                        y <= t.canonical.y + 1 &&
                        (!targetTile || targetTile.z > t.canonical.z)
                    ) {
                        targetTile = t;
                    }
                }

                if (!targetTile) {
                    return;
                }

                const box =
                    map.transform._verticalPerspectiveTransform._coveringTilesDetailsProvider.getTileBoundingVolume(
                        targetTile.canonical,
                        0,
                        0,
                        {}
                    );

                boxContext.hoveredTile = targetTile;
                boxContext.hoveredObb = box;
                map.redraw();
            };

            // create a custom style layer to implement the WebGL content
            const highlightLayer = {
                id: "highlight",
                type: "custom",
                shaderMap: new Map(),

                // Helper method for creating a shader based on current map projection - globe will automatically switch to mercator when some condition is fulfilled.
                getShader(gl, shaderDescription) {
                    // Pick a shader based on the current projection, defined by `variantName`.
                    if (this.shaderMap.has(shaderDescription.variantName)) {
                        return this.shaderMap.get(
                            shaderDescription.variantName
                        );
                    }

                    // Create GLSL source for vertex shader
                    //
                    // Note that we need to use a complex function to project from the source mercator
                    // coordinates to the globe. Internal shaders in MapLibre need to do this too.
                    // This is done using the `projectTile` function.
                    // In MapLibre, this function accepts vertex coordinates local to the current tile,
                    // in range 0..EXTENT (8192), but for custom layers MapLibre supplies uniforms such that
                    // the function accepts mercator coordinates of the whole world in range 0..1.
                    // This is controlled by the `u_projection_tile_mercator_coords` uniform.
                    //
                    // The `projectTile` function can also handle mercator to globe transitions and can
                    // handle the mercator projection - different code is supplied based on what projection is used,
                    // and for this reason we use different shaders based on what shader projection variant is currently used.
                    // See `variantName` usage earlier in this file.
                    //
                    // The code for the projection function and uniforms is also supplied by MapLibre
                    // and must be injected into custom layer shaders in order to draw on a globe.
                    // We simply use string interpolation for that here.
                    //
                    // See MapLibre source code for more details, especially src/shaders/_projection_globe.vertex.glsl
                    const vertexSource = `#version 300 es
            // Inject MapLibre projection code
            ${shaderDescription.vertexShaderPrelude}
            ${shaderDescription.define}

            uniform highp vec4 vertexA;
            uniform highp vec4 vertexB;

            in highp float a_pos;

            void main() {
                gl_Position = u_projection_matrix * mix(vertexA, vertexB, a_pos);
            }`;

                    // create GLSL source for fragment shader
                    const fragmentSource = `#version 300 es
                    uniform highp vec4 color;
            out highp vec4 fragColor;
            void main() {
                fragColor = color;
            }`;

                    // create a vertex shader
                    const vertexShader = gl.createShader(gl.VERTEX_SHADER);
                    gl.shaderSource(vertexShader, vertexSource);
                    gl.compileShader(vertexShader);

                    // create a fragment shader
                    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
                    gl.shaderSource(fragmentShader, fragmentSource);
                    gl.compileShader(fragmentShader);

                    // link the two shaders into a WebGL program
                    const program = gl.createProgram();
                    gl.attachShader(program, vertexShader);
                    gl.attachShader(program, fragmentShader);
                    gl.linkProgram(program);

                    this.aPos = gl.getAttribLocation(program, "a_pos");

                    this.shaderMap.set(shaderDescription.variantName, program);

                    return program;
                },

                // method called when the layer is added to the map
                // Search for StyleImageInterface in https://maplibre.org/maplibre-gl-js/docs/API/
                onAdd(map, gl) {
                    // create and initialize a WebGLBuffer to store vertex and color data
                    this.buffer = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
                    gl.bufferData(
                        gl.ARRAY_BUFFER,
                        new Float32Array([0, 1]),
                        gl.STATIC_DRAW
                    );
                    map.transform.overrideNearFarZ(1.0 / 64.0, 65536.0);
                },

                // method fired on each animation frame
                render(gl, args) {
                    if (!boxContext.hoveredObb) {
                        return;
                    }
                    let points = [];
                    const obb = boxContext.hoveredObb;
                    for (let i = 0; i < 8; i++) {
                        points.push([
                            obb.center[0] +
                                obb.axisX[0] * (((i >> 0) & 1) === 1 ? 1 : -1) +
                                obb.axisY[0] * (((i >> 1) & 1) === 1 ? 1 : -1) +
                                obb.axisZ[0] * (((i >> 2) & 1) === 1 ? 1 : -1),
                            obb.center[1] +
                                obb.axisX[1] * (((i >> 0) & 1) === 1 ? 1 : -1) +
                                obb.axisY[1] * (((i >> 1) & 1) === 1 ? 1 : -1) +
                                obb.axisZ[1] * (((i >> 2) & 1) === 1 ? 1 : -1),
                            obb.center[2] +
                                obb.axisX[2] * (((i >> 0) & 1) === 1 ? 1 : -1) +
                                obb.axisY[2] * (((i >> 1) & 1) === 1 ? 1 : -1) +
                                obb.axisZ[2] * (((i >> 2) & 1) === 1 ? 1 : -1),
                            1,
                        ]);
                    }
                    const pointsAabb = [];
                    for (let i = 0; i < 8; i++) {
                        pointsAabb.push([
                            ((i >> 0) & 1) === 1 ? obb.min[0] : obb.max[0],
                            ((i >> 1) & 1) === 1 ? obb.min[1] : obb.max[1],
                            ((i >> 2) & 1) === 1 ? obb.min[2] : obb.max[2],
                            1,
                        ]);
                        // pointsAabb.push([
                        //     ((i >> 0) & 1) === 1 ? 1 : -1,
                        //     ((i >> 1) & 1) === 1 ? 1 : -1,
                        //     ((i >> 2) & 1) === 1 ? 1 : -1,
                        //     1,
                        // ]);
                    }

                    const tilePoints = [];

                    const pointsPerSide = 16;
                    const tileSize =
                        1.0 / (1 << boxContext.hoveredTile.canonical.z);
                    const tileX = boxContext.hoveredTile.canonical.x * tileSize;
                    const tileY = boxContext.hoveredTile.canonical.y * tileSize;
                    for (let side = 0; side < 4; side++) {
                        let baseX = 0;
                        let baseY = 0;
                        let dirX = 0;
                        let dirY = 0;
                        if (side === 0) {
                            baseX = tileX;
                            baseY = tileY;
                            dirX = tileSize;
                            dirY = 0;
                        }
                        if (side === 1) {
                            baseX = tileX + tileSize;
                            baseY = tileY;
                            dirX = 0;
                            dirY = tileSize;
                        }
                        if (side === 2) {
                            baseX = tileX + tileSize;
                            baseY = tileY + tileSize;
                            dirX = -tileSize;
                            dirY = 0;
                        }
                        if (side === 3) {
                            baseX = tileX;
                            baseY = tileY + tileSize;
                            dirX = 0;
                            dirY = -tileSize;
                        }
                        for (let i = 0; i < pointsPerSide; i++) {
                            const mix = i / pointsPerSide;
                            const mercatorX = baseX + dirX * mix;
                            const mercatorY = baseY + dirY * mix;
                            const ll = new maplibregl.MercatorCoordinate(
                                mercatorX,
                                mercatorY
                            ).toLngLat();
                            const x = (ll.lng * Math.PI) / 180.0;
                            const y = (ll.lat * Math.PI) / 180.0;
                            const len = Math.cos(y);
                            tilePoints.push([
                                Math.sin(x) * len,
                                Math.sin(y),
                                Math.cos(x) * len,
                                1,
                            ]);
                        }
                    }
                    const tileLines = [];
                    for (let i = 0; i < tilePoints.length; i++) {
                        const nextI = (i + 1) % tilePoints.length;
                        tileLines.push([tilePoints[i], tilePoints[nextI]]);
                    }

                    this.drawLines(gl, args, [1, 0, 0, 1], tileLines);
                    this.drawLines(
                        gl,
                        args,
                        [0, 1, 0, 1],
                        this.linesFromPoints(pointsAabb)
                    );
                    this.drawLines(
                        gl,
                        args,
                        [1, 0, 1, 1],
                        this.linesFromPoints(points)
                    );
                },

                linesFromPoints(points) {
                    return [
                        [points[0], points[1]],
                        [points[0], points[2]],
                        [points[1], points[3]],
                        [points[2], points[3]],
                        [points[0], points[4]],
                        [points[1], points[5]],
                        [points[2], points[6]],
                        [points[3], points[7]],
                        [points[4], points[5]],
                        [points[4], points[6]],
                        [points[5], points[7]],
                        [points[6], points[7]],
                    ];
                },

                drawLines(gl, args, color, verts) {
                    const program = this.getShader(gl, args.shaderData);
                    gl.useProgram(program);
                    gl.uniformMatrix4fv(
                        gl.getUniformLocation(
                            program,
                            "u_projection_fallback_matrix"
                        ),
                        false,
                        args.defaultProjectionData.fallbackMatrix // convert mat4 from gl-matrix to a plain array
                    );
                    gl.uniformMatrix4fv(
                        gl.getUniformLocation(program, "u_projection_matrix"),
                        false,
                        args.defaultProjectionData.mainMatrix // convert mat4 from gl-matrix to a plain array
                    );
                    gl.uniform4f(
                        gl.getUniformLocation(
                            program,
                            "u_projection_tile_mercator_coords"
                        ),
                        ...args.defaultProjectionData.tileMercatorCoords
                    );
                    gl.uniform4f(
                        gl.getUniformLocation(
                            program,
                            "u_projection_clipping_plane"
                        ),
                        ...args.defaultProjectionData.clippingPlane
                    );
                    gl.uniform1f(
                        gl.getUniformLocation(
                            program,
                            "u_projection_transition"
                        ),
                        args.defaultProjectionData.projectionTransition
                    );
                    gl.uniform4f(
                        gl.getUniformLocation(program, "color"),
                        ...color
                    );

                    gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
                    gl.enableVertexAttribArray(this.aPos);
                    gl.vertexAttribPointer(this.aPos, 1, gl.FLOAT, false, 0, 0);
                    gl.enable(gl.BLEND);
                    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
                    for (let i = 0; i < verts.length; i++) {
                        const a = verts[i][0];
                        const b = verts[i][1];
                        gl.uniform4f(
                            gl.getUniformLocation(program, "vertexA"),
                            ...a
                        );
                        gl.uniform4f(
                            gl.getUniformLocation(program, "vertexB"),
                            ...b
                        );
                        gl.drawArrays(gl.LINES, 0, 2);
                    }
                },
            };

            // add the custom style layer to the map
            map.on("load", () => {
                map.addLayer(highlightLayer, "crimea-fill");
            });
        </script>
    </body>
</html>
