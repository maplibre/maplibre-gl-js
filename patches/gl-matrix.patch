diff --git a/index.d.ts b/index.d.ts
index e1aff2f2164afe260c6e670d523e9f4934d3a370..032ba907cde2b9d1fbb9012e0a838892206ce18e 100644
--- a/index.d.ts
+++ b/index.d.ts
@@ -1,99 +1,156 @@
 declare module "gl-matrix" {
 
 interface IndexedCollection extends Iterable<number> {
-    readonly length: number;
-    [index: number]: number;
+  readonly length: number;
+  [index: number]: number;
 }
 
+// Helper type to generate numeric range 0 to N-1
+type NumericRange<N extends number, Acc extends unknown[] = []> =
+  Acc['length'] extends N
+    ? Acc[number]
+    : NumericRange<N, [...Acc, Acc['length']]>;
+
+// Bounded Float32Array type that only allows valid indices
+type TypedArrayTuple<Kind, Length extends number> =
+  Omit<Kind, number | 'length'> & {
+    [K in NumericRange<Length>]: number;
+  } & { readonly length: Length; };
+
+type ToTuple<T, Tuple extends any[] | readonly any[]> = T extends Array<number> ? Tuple : TypedArrayTuple<T, Tuple['length']>
+
+// Users can augment this interface to override the array type
+// Example: interface Overrides { arrayType: Float64Array }
+interface Overrides { }
+
+export type DefaultArrayType = Overrides extends { arrayType: infer T } ? T : Float32Array
+
 // prettier-ignore
-export type mat2 =
-  | [number, number, 
-     number, number]
-  | IndexedCollection;
+export type Mat2Tuple = [
+  number, number,
+  number, number
+]
+export type Mat2Result<T extends IndexedCollection> = ToTuple<T, Mat2Tuple>;
+export type mat2<T extends IndexedCollection | Mat2Tuple = IndexedCollection | Mat2Tuple> = T;
 
 // prettier-ignore
-export type mat2d =
-  | [number, number, 
-     number, number, 
-     number, number]
-  | IndexedCollection;
+export type Mat2dTuple = [
+  number, number,
+  number, number,
+  number, number
+]
+export type Mat2dResult<T extends IndexedCollection> = ToTuple<T, Mat2dTuple>;
+export type mat2d<T extends IndexedCollection | Mat2dTuple = IndexedCollection | Mat2dTuple> = Mat2dTuple;
 
 // prettier-ignore
-export type mat3 =
-  | [number, number, number, 
-     number, number, number, 
-     number, number, number]
-  | IndexedCollection;
+export type Mat3Tuple = [
+  number, number, number,
+  number, number, number,
+  number, number, number
+]
+export type Mat3Result<T extends IndexedCollection> = ToTuple<T, Mat3Tuple>;
+export type mat3<T extends IndexedCollection | Mat3Tuple = IndexedCollection | Mat3Tuple> = T;
 
 // prettier-ignore
-export type mat4 =
-  | [number, number, number, number,
-     number, number, number, number,
-     number, number, number, number,
-     number, number, number, number]
-  | IndexedCollection;
+export type Mat4Tuple = [
+  number, number, number, number,
+  number, number, number, number,
+  number, number, number, number,
+  number, number, number, number
+]
+export type Mat4Result<T extends IndexedCollection> = ToTuple<T, Mat4Tuple>;
+export type mat4<T extends IndexedCollection | Mat4Tuple = IndexedCollection | Mat4Tuple> = T;
 
-export type quat = [number, number, number, number] | IndexedCollection;
+// prettier-ignore
+export type QuatTuple = [number, number, number, number]
+export type QuatResult<T extends IndexedCollection> = ToTuple<T, QuatTuple>;
+export type quat<T extends IndexedCollection | QuatTuple = IndexedCollection | QuatTuple> = T;
 
 // prettier-ignore
-export type quat2 =
-  | [number, number, number, number, 
-    number, number, number, number]
-  | IndexedCollection;
+export type Quat2Tuple = [
+  number, number, number, number,
+  number, number, number, number
+]
+export type Quat2Result<T extends IndexedCollection> = ToTuple<T, Quat2Tuple>;
+export type quat2<T extends IndexedCollection | Quat2Tuple = IndexedCollection | Quat2Tuple> = T
+
+export type Vec2Tuple = [number, number];
+export type Vec2Result<T extends IndexedCollection> = ToTuple<T, Vec2Tuple>;
+export type vec2<T extends IndexedCollection | Vec2Tuple = IndexedCollection | Vec2Tuple> = T;
 
-export type vec2 = [number, number] | IndexedCollection;
-export type vec3 = [number, number, number] | IndexedCollection;
-export type vec4 = [number, number, number, number] | IndexedCollection;
+export type Vec3Tuple = [number, number, number];
+export type Vec3Result<T extends IndexedCollection> = ToTuple<T, Vec3Tuple>;
+export type vec3<T extends IndexedCollection | Vec3Tuple = IndexedCollection | Vec3Tuple> = T;
+
+export type Vec4Tuple = [number, number, number, number];
+export type Vec4Result<T extends IndexedCollection> = ToTuple<T, Vec4Tuple>;
+export type vec4<T extends IndexedCollection | Vec4Tuple = IndexedCollection | Vec4Tuple> = T;
+
+// prettier-ignore
+export type ReadonlyMat2Tuple = readonly [
+  number, number,
+  number, number
+]
+export type ReadonlyMat2Result<T extends IndexedCollection> = ToTuple<T, ReadonlyMat2Tuple>;
+export type ReadonlyMat2<T extends IndexedCollection | ReadonlyMat2Tuple = IndexedCollection | ReadonlyMat2Tuple> = T;
 
 // prettier-ignore
-export type ReadonlyMat2 =
-  | readonly [
-      number, number,
-      number, number
-    ]
-  | IndexedCollection;
+export type ReadonlyMat2dTuple = readonly [
+  number, number,
+  number, number,
+  number, number
+]
+export type ReadonlyMat2dResult<T extends IndexedCollection> = ToTuple<T, ReadonlyMat2dTuple>;
+export type ReadonlyMat2d<T extends IndexedCollection | ReadonlyMat2dTuple = IndexedCollection | ReadonlyMat2dTuple> = T;
 
 // prettier-ignore
-export type ReadonlyMat2d =
-  | readonly [
-      number, number,
-      number, number,
-      number, number
-    ]
-  | IndexedCollection;
+export type ReadonlyMat3Tuple = readonly [
+  number, number, number,
+  number, number, number,
+  number, number, number
+]
+export type ReadonlyMat3Result<T extends IndexedCollection> = ToTuple<T, ReadonlyMat3Tuple>;
+export type ReadonlyMat3<T extends IndexedCollection | ReadonlyMat3Tuple = IndexedCollection | ReadonlyMat3Tuple> = T;
 
 // prettier-ignore
-export type ReadonlyMat3 =
-  | readonly [
-      number, number, number,
-      number, number, number,
-      number, number, number
-    ]
-  | IndexedCollection;
+export type ReadonlyMat4Tuple = readonly [
+  number, number, number, number,
+  number, number, number, number,
+  number, number, number, number,
+  number, number, number, number
+]
+export type ReadonlyMat4Result<T extends IndexedCollection> = ToTuple<T, ReadonlyMat4Tuple>;
+export type ReadonlyMat4<T extends IndexedCollection | ReadonlyMat4Tuple = IndexedCollection | ReadonlyMat4Tuple> = T;
+
+export type ReadonlyQuatTuple = readonly [number, number, number, number];
+export type ReadonlyQuatResult<T extends IndexedCollection> = ToTuple<T, ReadonlyQuatTuple>;
+export type ReadonlyQuat<T extends IndexedCollection | ReadonlyQuatTuple = IndexedCollection | ReadonlyQuatTuple> = T;
 
+export type ReadonlyQuat2Tuple = readonly [
+  number,
+  number,
+  number,
+  number,
+  number,
+  number,
+  number,
+  number
+];
+export type ReadonlyQuat2Result<T extends IndexedCollection> = ToTuple<T, ReadonlyQuat2Tuple>;
 // prettier-ignore
-export type ReadonlyMat4 =
-  | readonly [
-      number, number, number, number,
-      number, number, number, number,
-      number, number, number, number,
-      number, number, number, number
-    ]
-  | IndexedCollection;
+export type ReadonlyQuat2<T extends IndexedCollection | ReadonlyQuat2Tuple = IndexedCollection | ReadonlyQuat2Tuple> = T;
 
-export type ReadonlyQuat =
-  | readonly [number, number, number, number]
-  | IndexedCollection;
+export type ReadonlyVec2Tuple = readonly [number, number];
+export type ReadonlyVec2Result<T extends IndexedCollection> = ToTuple<T, ReadonlyVec2Tuple>;
+export type ReadonlyVec2<T extends IndexedCollection | ReadonlyVec2Tuple = IndexedCollection | ReadonlyVec2Tuple> = T
 
-export type ReadonlyQuat2 =
-  | readonly [number, number, number, number, number, number, number, number]
-  | IndexedCollection;
+export type ReadonlyVec3Tuple = readonly [number, number, number];
+export type ReadonlyVec3Result<T extends IndexedCollection> = ToTuple<T, ReadonlyVec3Tuple>;
+export type ReadonlyVec3<T extends IndexedCollection | ReadonlyVec4Tuple = IndexedCollection | ReadonlyVec3Tuple> = T;
 
-export type ReadonlyVec2 = readonly [number, number] | IndexedCollection;
-export type ReadonlyVec3 = readonly [number, number, number] | IndexedCollection;
-export type ReadonlyVec4 =
-  | readonly [number, number, number, number]
-  | IndexedCollection;
+export type ReadonlyVec4Tuple = readonly [number, number, number, number];
+export type ReadonlyVec4Result<T extends IndexedCollection> = ToTuple<T, ReadonlyVec4Tuple>;
+export type ReadonlyVec4<T extends IndexedCollection | ReadonlyVec4Tuple = IndexedCollection | ReadonlyVec4Tuple> = T;
 
 export namespace glMatrix {
     /**
@@ -149,31 +206,33 @@ export namespace mat2 {
     /**
      * Creates a new identity mat2
      *
-     * @returns {mat2} a new 2x2 matrix
+     * @returns {mat2<DefaultArrayType>} a new 2x2 matrix
      */
-    export function create(): mat2;
+    export function create(): mat2<DefaultArrayType>;
     /**
      * Creates a new mat2 initialized with values from an existing matrix
      *
      * @param {ReadonlyMat2} a matrix to clone
-     * @returns {mat2} a new 2x2 matrix
+     * @returns {mat2<DefaultArrayType} a new 2x2 matrix
      */
-    export function clone(a: ReadonlyMat2): mat2;
+    export function clone(a: ReadonlyMat2): mat2<DefaultArrayType>;
     /**
      * Copy the values from one mat2 to another
      *
-     * @param {mat2} out the receiving matrix
+     * @template {mat2} T
+     * @param {T} out the receiving matrix
      * @param {ReadonlyMat2} a the source matrix
-     * @returns {mat2} out
+     * @returns {Mat2Result<T>} out
      */
-    export function copy(out: mat2, a: ReadonlyMat2): mat2;
+    export function copy<T extends mat2>(out: T, a: ReadonlyMat2): Mat2Result<T>;
     /**
      * Set a mat2 to the identity matrix
      *
-     * @param {mat2} out the receiving matrix
-     * @returns {mat2} out
+     * @template {mat2} T
+     * @param {T} out the receiving matrix
+     * @returns {Mat2Result<T>} out
      */
-    export function identity(out: mat2): mat2;
+    export function identity<T extends mat2>(out: T): Mat2Result<T>;
     /**
      * Create a new mat2 with the given values
      *
@@ -181,44 +240,48 @@ export namespace mat2 {
      * @param {Number} m01 Component in column 0, row 1 position (index 1)
      * @param {Number} m10 Component in column 1, row 0 position (index 2)
      * @param {Number} m11 Component in column 1, row 1 position (index 3)
-     * @returns {mat2} out A new 2x2 matrix
+     * @returns {mat2<DefaultArrayType>} out A new 2x2 matrix
      */
-    export function fromValues(m00: number, m01: number, m10: number, m11: number): mat2;
+    export function fromValues(m00: number, m01: number, m10: number, m11: number): mat2<DefaultArrayType>;
     /**
      * Set the components of a mat2 to the given values
      *
-     * @param {mat2} out the receiving matrix
+     * @template {mat2} T
+     * @param {T} out the receiving matrix
      * @param {Number} m00 Component in column 0, row 0 position (index 0)
      * @param {Number} m01 Component in column 0, row 1 position (index 1)
      * @param {Number} m10 Component in column 1, row 0 position (index 2)
      * @param {Number} m11 Component in column 1, row 1 position (index 3)
-     * @returns {mat2} out
+     * @returns {Mat2Result<T>} out
      */
-    export function set(out: mat2, m00: number, m01: number, m10: number, m11: number): mat2;
+    export function set<T extends mat2>(out: T, m00: number, m01: number, m10: number, m11: number): Mat2Result<T>;
     /**
      * Transpose the values of a mat2
      *
-     * @param {mat2} out the receiving matrix
+     * @template {mat2} T
+     * @param {T} out the receiving matrix
      * @param {ReadonlyMat2} a the source matrix
-     * @returns {mat2} out
+     * @returns {Mat2Result<T>} out
      */
-    export function transpose(out: mat2, a: ReadonlyMat2): mat2;
+    export function transpose<T extends mat2>(out: T, a: ReadonlyMat2): Mat2Result<T>;
     /**
      * Inverts a mat2
      *
-     * @param {mat2} out the receiving matrix
+     * @template {mat2} T
+     * @param {T} out the receiving matrix
      * @param {ReadonlyMat2} a the source matrix
-     * @returns {mat2 | null} out, or null if source matrix is not invertible
+     * @returns {Mat2Result<T> | null} out, or null if source matrix is not invertible
      */
-    export function invert(out: mat2, a: ReadonlyMat2): mat2 | null;
+    export function invert<T extends mat2>(out: T, a: ReadonlyMat2): Mat2Result<T> | null;
     /**
      * Calculates the adjugate of a mat2
      *
-     * @param {mat2} out the receiving matrix
+     * @template {mat2} T
+     * @param {T} out the receiving matrix
      * @param {ReadonlyMat2} a the source matrix
-     * @returns {mat2} out
+     * @returns {Mat2Result<T>} out
      */
-    export function adjoint(out: mat2, a: ReadonlyMat2): mat2;
+    export function adjoint<T extends mat2>(out: T, a: ReadonlyMat2): Mat2Result<T>;
     /**
      * Calculates the determinant of a mat2
      *
@@ -229,30 +292,33 @@ export namespace mat2 {
     /**
      * Multiplies two mat2's
      *
-     * @param {mat2} out the receiving matrix
+     * @template {mat2} T
+     * @param {T} out the receiving matrix
      * @param {ReadonlyMat2} a the first operand
      * @param {ReadonlyMat2} b the second operand
-     * @returns {mat2} out
+     * @returns {Mat2Result<T>} out
      */
-    export function multiply(out: mat2, a: ReadonlyMat2, b: ReadonlyMat2): mat2;
+    export function multiply<T extends mat2>(out: T, a: ReadonlyMat2, b: ReadonlyMat2): Mat2Result<T>;
     /**
      * Rotates a mat2 by the given angle
      *
-     * @param {mat2} out the receiving matrix
+     * @template {mat2} T
+     * @param {T} out the receiving matrix
      * @param {ReadonlyMat2} a the matrix to rotate
      * @param {Number} rad the angle to rotate the matrix by
-     * @returns {mat2} out
+     * @returns {Mat2Result<T>} out
      */
-    export function rotate(out: mat2, a: ReadonlyMat2, rad: number): mat2;
+    export function rotate<T extends mat2>(out: T, a: ReadonlyMat2, rad: number): Mat2Result<T>;
     /**
      * Scales the mat2 by the dimensions in the given vec2
      *
-     * @param {mat2} out the receiving matrix
+     * @template {mat2} T
+     * @param {T} out the receiving matrix
      * @param {ReadonlyMat2} a the matrix to rotate
      * @param {ReadonlyVec2} v the vec2 to scale the matrix by
-     * @returns {mat2} out
+     * @returns {Mat2Result<T>} out
      **/
-    export function scale(out: mat2, a: ReadonlyMat2, v: ReadonlyVec2): mat2;
+    export function scale<T extends mat2>(out: T, a: ReadonlyMat2, v: ReadonlyVec2): Mat2Result<T>;
     /**
      * Creates a matrix from a given angle
      * This is equivalent to (but much faster than):
@@ -260,11 +326,12 @@ export namespace mat2 {
      *     mat2.identity(dest);
      *     mat2.rotate(dest, dest, rad);
      *
-     * @param {mat2} out mat2 receiving operation result
+     * @template {mat2} T
+     * @param {T} out mat2 receiving operation result
      * @param {Number} rad the angle to rotate the matrix by
-     * @returns {mat2} out
+     * @returns {Mat2Result<T>} out
      */
-    export function fromRotation(out: mat2, rad: number): mat2;
+    export function fromRotation<T extends mat2>(out: T, rad: number): Mat2Result<T>;
     /**
      * Creates a matrix from a vector scaling
      * This is equivalent to (but much faster than):
@@ -272,11 +339,12 @@ export namespace mat2 {
      *     mat2.identity(dest);
      *     mat2.scale(dest, dest, vec);
      *
-     * @param {mat2} out mat2 receiving operation result
+     * @template {mat2} T
+     * @param {T} out mat2 receiving operation result
      * @param {ReadonlyVec2} v Scaling vector
-     * @returns {mat2} out
+     * @returns {Mat2Result<T>} out
      */
-    export function fromScaling(out: mat2, v: ReadonlyVec2): mat2;
+    export function fromScaling<T extends mat2>(out: T, v: ReadonlyVec2): Mat2Result<T>;
     /**
      * Returns a string representation of a mat2
      *
@@ -298,25 +366,27 @@ export namespace mat2 {
      * @param {ReadonlyMat2} U the upper triangular matrix
      * @param {ReadonlyMat2} a the input matrix to factorize
      */
-    export function LDU(L: ReadonlyMat2, D: ReadonlyMat2, U: ReadonlyMat2, a: ReadonlyMat2): ReadonlyMat2[];
+    export function LDU(L: ReadonlyMat2, D: ReadonlyMat2, U: ReadonlyMat2, a: ReadonlyMat2): IndexedCollection[];
     /**
      * Adds two mat2's
      *
-     * @param {mat2} out the receiving matrix
+     * @template {mat2} T
+     * @param {T} out the receiving matrix
      * @param {ReadonlyMat2} a the first operand
      * @param {ReadonlyMat2} b the second operand
-     * @returns {mat2} out
+     * @returns {Mat2Result<T>} out
      */
-    export function add(out: mat2, a: ReadonlyMat2, b: ReadonlyMat2): mat2;
+    export function add<T extends mat2>(out: T, a: ReadonlyMat2, b: ReadonlyMat2): Mat2Result<T>;
     /**
      * Subtracts matrix b from matrix a
      *
-     * @param {mat2} out the receiving matrix
+     * @template {mat2} T
+     * @param {T} out the receiving matrix
      * @param {ReadonlyMat2} a the first operand
      * @param {ReadonlyMat2} b the second operand
-     * @returns {mat2} out
+     * @returns {Mat2Result<T>} out
      */
-    export function subtract(out: mat2, a: ReadonlyMat2, b: ReadonlyMat2): mat2;
+    export function subtract<T extends mat2>(out: T, a: ReadonlyMat2, b: ReadonlyMat2): Mat2Result<T>;
     /**
      * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
      *
@@ -336,40 +406,44 @@ export namespace mat2 {
     /**
      * Multiply each element of the matrix by a scalar.
      *
-     * @param {mat2} out the receiving matrix
+     * @template {mat2} T
+     * @param {T} out the receiving matrix
      * @param {ReadonlyMat2} a the matrix to scale
      * @param {Number} b amount to scale the matrix's elements by
-     * @returns {mat2} out
+     * @returns {Mat2Result<T>} out
      */
-    export function multiplyScalar(out: mat2, a: ReadonlyMat2, b: number): mat2;
+    export function multiplyScalar<T extends mat2>(out: T, a: ReadonlyMat2, b: number): Mat2Result<T>;
     /**
      * Adds two mat2's after multiplying each element of the second operand by a scalar value.
      *
-     * @param {mat2} out the receiving vector
+     * @template {mat2} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyMat2} a the first operand
      * @param {ReadonlyMat2} b the second operand
      * @param {Number} scale the amount to scale b's elements by before adding
-     * @returns {mat2} out
+     * @returns {Mat2Result<T>} out
      */
-    export function multiplyScalarAndAdd(out: mat2, a: ReadonlyMat2, b: ReadonlyMat2, scale: number): mat2;
+    export function multiplyScalarAndAdd<T extends mat2>(out: T, a: ReadonlyMat2, b: ReadonlyMat2, scale: number): Mat2Result<T>;
     /**
      * Multiplies two mat2's
      *
-     * @param {mat2} out the receiving matrix
+     * @template {mat2} T
+     * @param {T} out the receiving matrix
      * @param {ReadonlyMat2} a the first operand
      * @param {ReadonlyMat2} b the second operand
-     * @returns {mat2} out
+     * @returns {Mat2Result<T>} out
      */
-    export function mul(out: mat2, a: ReadonlyMat2, b: ReadonlyMat2): mat2;
+    export function mul<T extends mat2>(out: T, a: ReadonlyMat2, b: ReadonlyMat2): Mat2Result<T>;
     /**
      * Subtracts matrix b from matrix a
      *
-     * @param {mat2} out the receiving matrix
+     * @template {mat2} T
+     * @param {T} out the receiving matrix
      * @param {ReadonlyMat2} a the first operand
      * @param {ReadonlyMat2} b the second operand
-     * @returns {mat2} out
+     * @returns {Mat2Result<T>} out
      */
-    export function sub(out: mat2, a: ReadonlyMat2, b: ReadonlyMat2): mat2;
+    export function sub<T extends mat2>(out: T, a: ReadonlyMat2, b: ReadonlyMat2): Mat2Result<T>;
 }
 export namespace mat2d {
     /**
@@ -393,31 +467,33 @@ export namespace mat2d {
     /**
      * Creates a new identity mat2d
      *
-     * @returns {mat2d} a new 2x3 matrix
+     * @returns {mat2d<DefaultArrayType>} a new 2x3 matrix
      */
-    export function create(): mat2d;
+    export function create(): mat2d<DefaultArrayType>;
     /**
      * Creates a new mat2d initialized with values from an existing matrix
      *
      * @param {ReadonlyMat2d} a matrix to clone
-     * @returns {mat2d} a new 2x3 matrix
+     * @returns {mat2d<DefaultArrayType>} a new 2x3 matrix
      */
-    export function clone(a: ReadonlyMat2d): mat2d;
+    export function clone(a: ReadonlyMat2d): mat2d<DefaultArrayType>;
     /**
      * Copy the values from one mat2d to another
      *
-     * @param {mat2d} out the receiving matrix
+     * @template {mat2d} T
+     * @param {T} out the receiving matrix
      * @param {ReadonlyMat2d} a the source matrix
-     * @returns {mat2d} out
+     * @returns {Mat2dResult<T>} out
      */
-    export function copy(out: mat2d, a: ReadonlyMat2d): mat2d;
+    export function copy<T extends mat2d>(out: T, a: ReadonlyMat2d): Mat2dResult<T>;
     /**
      * Set a mat2d to the identity matrix
      *
-     * @param {mat2d} out the receiving matrix
-     * @returns {mat2d} out
+     * @template {mat2d} T
+     * @param {T} out the receiving matrix
+     * @returns {Mat2dResult<T>} out
      */
-    export function identity(out: mat2d): mat2d;
+    export function identity<T extends mat2d>(out: T): Mat2dResult<T>;
     /**
      * Create a new mat2d with the given values
      *
@@ -427,30 +503,32 @@ export namespace mat2d {
      * @param {Number} d Component D (index 3)
      * @param {Number} tx Component TX (index 4)
      * @param {Number} ty Component TY (index 5)
-     * @returns {mat2d} A new mat2d
+     * @returns {mat2d<DefaultArrayType>} A new mat2d
      */
-    export function fromValues(a: number, b: number, c: number, d: number, tx: number, ty: number): mat2d;
+    export function fromValues(a: number, b: number, c: number, d: number, tx: number, ty: number): mat2d<DefaultArrayType>;
     /**
      * Set the components of a mat2d to the given values
      *
-     * @param {mat2d} out the receiving matrix
+     * @template {mat2d} T
+     * @param {T} out the receiving matrix
      * @param {Number} a Component A (index 0)
      * @param {Number} b Component B (index 1)
      * @param {Number} c Component C (index 2)
      * @param {Number} d Component D (index 3)
      * @param {Number} tx Component TX (index 4)
      * @param {Number} ty Component TY (index 5)
-     * @returns {mat2d} out
+     * @returns {Mat2dResult<T>} out
      */
-    export function set(out: mat2d, a: number, b: number, c: number, d: number, tx: number, ty: number): mat2d;
+    export function set<T extends mat2d>(out: T, a: number, b: number, c: number, d: number, tx: number, ty: number): Mat2dResult<T>;
     /**
      * Inverts a mat2d
      *
-     * @param {mat2d} out the receiving matrix
+     * @template {mat2d} T
+     * @param {T} out the receiving matrix
      * @param {ReadonlyMat2d} a the source matrix
-     * @returns {mat2d | null} out, or null if source matrix is not invertible
+     * @returns {Mat2dResult<T> | null} out, or null if source matrix is not invertible
      */
-    export function invert(out: mat2d, a: ReadonlyMat2d): mat2d | null;
+    export function invert<T extends mat2d>(out: T, a: ReadonlyMat2d): Mat2dResult<T> | null;
     /**
      * Calculates the determinant of a mat2d
      *
@@ -461,39 +539,43 @@ export namespace mat2d {
     /**
      * Multiplies two mat2d's
      *
-     * @param {mat2d} out the receiving matrix
+     * @template {mat2d} T
+     * @param {T} out the receiving matrix
      * @param {ReadonlyMat2d} a the first operand
      * @param {ReadonlyMat2d} b the second operand
-     * @returns {mat2d} out
+     * @returns {Mat2dResult<T>} out
      */
-    export function multiply(out: mat2d, a: ReadonlyMat2d, b: ReadonlyMat2d): mat2d;
+    export function multiply<T extends mat2d>(out: T, a: ReadonlyMat2d, b: ReadonlyMat2d): Mat2dResult<T>;
     /**
      * Rotates a mat2d by the given angle
      *
-     * @param {mat2d} out the receiving matrix
+     * @template {mat2d} T
+     * @param {T} out the receiving matrix
      * @param {ReadonlyMat2d} a the matrix to rotate
      * @param {Number} rad the angle to rotate the matrix by
-     * @returns {mat2d} out
+     * @returns {Mat2dResult<T>} out
      */
-    export function rotate(out: mat2d, a: ReadonlyMat2d, rad: number): mat2d;
+    export function rotate<T extends mat2d>(out: T, a: ReadonlyMat2d, rad: number): Mat2dResult<T>;
     /**
      * Scales the mat2d by the dimensions in the given vec2
      *
-     * @param {mat2d} out the receiving matrix
+     * @template {mat2d} T
+     * @param {T} out the receiving matrix
      * @param {ReadonlyMat2d} a the matrix to translate
      * @param {ReadonlyVec2} v the vec2 to scale the matrix by
-     * @returns {mat2d} out
+     * @returns {Mat2dResult<T>} out
      **/
-    export function scale(out: mat2d, a: ReadonlyMat2d, v: ReadonlyVec2): mat2d;
+    export function scale<T extends mat2d>(out: T, a: ReadonlyMat2d, v: ReadonlyVec2): Mat2dResult<T>;
     /**
      * Translates the mat2d by the dimensions in the given vec2
      *
-     * @param {mat2d} out the receiving matrix
+     * @template {mat2d} T
+     * @param {T} out the receiving matrix
      * @param {ReadonlyMat2d} a the matrix to translate
      * @param {ReadonlyVec2} v the vec2 to translate the matrix by
-     * @returns {mat2d} out
+     * @returns {Mat2dResult<T>} out
      **/
-    export function translate(out: mat2d, a: ReadonlyMat2d, v: ReadonlyVec2): mat2d;
+    export function translate<T extends mat2d>(out: T, a: ReadonlyMat2d, v: ReadonlyVec2): Mat2dResult<T>;
     /**
      * Creates a matrix from a given angle
      * This is equivalent to (but much faster than):
@@ -501,11 +583,12 @@ export namespace mat2d {
      *     mat2d.identity(dest);
      *     mat2d.rotate(dest, dest, rad);
      *
-     * @param {mat2d} out mat2d receiving operation result
+     * @template {mat2d} T
+     * @param {T} out mat2d receiving operation result
      * @param {Number} rad the angle to rotate the matrix by
-     * @returns {mat2d} out
+     * @returns {Mat2dResult<T>} out
      */
-    export function fromRotation(out: mat2d, rad: number): mat2d;
+    export function fromRotation<T extends mat2d>(out: T, rad: number): Mat2dResult<T>;
     /**
      * Creates a matrix from a vector scaling
      * This is equivalent to (but much faster than):
@@ -513,11 +596,12 @@ export namespace mat2d {
      *     mat2d.identity(dest);
      *     mat2d.scale(dest, dest, vec);
      *
-     * @param {mat2d} out mat2d receiving operation result
+     * @template {mat2d} T
+     * @param {T} out mat2d receiving operation result
      * @param {ReadonlyVec2} v Scaling vector
-     * @returns {mat2d} out
+     * @returns {Mat2dResult<T>} out
      */
-    export function fromScaling(out: mat2d, v: ReadonlyVec2): mat2d;
+    export function fromScaling<T extends mat2d>(out: T, v: ReadonlyVec2): Mat2dResult<T>;
     /**
      * Creates a matrix from a vector translation
      * This is equivalent to (but much faster than):
@@ -525,11 +609,12 @@ export namespace mat2d {
      *     mat2d.identity(dest);
      *     mat2d.translate(dest, dest, vec);
      *
-     * @param {mat2d} out mat2d receiving operation result
+     * @template {mat2d} T
+     * @param {T} out mat2d receiving operation result
      * @param {ReadonlyVec2} v Translation vector
-     * @returns {mat2d} out
+     * @returns {Mat2dResult<T>} out
      */
-    export function fromTranslation(out: mat2d, v: ReadonlyVec2): mat2d;
+    export function fromTranslation<T extends mat2d>(out: T, v: ReadonlyVec2): Mat2dResult<T>;
     /**
      * Returns a string representation of a mat2d
      *
@@ -547,40 +632,44 @@ export namespace mat2d {
     /**
      * Adds two mat2d's
      *
-     * @param {mat2d} out the receiving matrix
+     * @template {mat2d} T
+     * @param {T} out the receiving matrix
      * @param {ReadonlyMat2d} a the first operand
      * @param {ReadonlyMat2d} b the second operand
-     * @returns {mat2d} out
+     * @returns {Mat2dResult<T>} out
      */
-    export function add(out: mat2d, a: ReadonlyMat2d, b: ReadonlyMat2d): mat2d;
+    export function add<T extends mat2d>(out: T, a: ReadonlyMat2d, b: ReadonlyMat2d): Mat2dResult<T>;
     /**
      * Subtracts matrix b from matrix a
      *
-     * @param {mat2d} out the receiving matrix
+     * @template {mat2d} T
+     * @param {T} out the receiving matrix
      * @param {ReadonlyMat2d} a the first operand
      * @param {ReadonlyMat2d} b the second operand
-     * @returns {mat2d} out
+     * @returns {Mat2dResult<T>} out
      */
-    export function subtract(out: mat2d, a: ReadonlyMat2d, b: ReadonlyMat2d): mat2d;
+    export function subtract<T extends mat2d>(out: T, a: ReadonlyMat2d, b: ReadonlyMat2d): Mat2dResult<T>;
     /**
      * Multiply each element of the matrix by a scalar.
      *
-     * @param {mat2d} out the receiving matrix
+     * @template {mat2d} T
+     * @param {T} out the receiving matrix
      * @param {ReadonlyMat2d} a the matrix to scale
      * @param {Number} b amount to scale the matrix's elements by
-     * @returns {mat2d} out
+     * @returns {Mat2dResult<T>} out
      */
-    export function multiplyScalar(out: mat2d, a: ReadonlyMat2d, b: number): mat2d;
+    export function multiplyScalar<T extends mat2d>(out: T, a: ReadonlyMat2d, b: number): Mat2dResult<T>;
     /**
      * Adds two mat2d's after multiplying each element of the second operand by a scalar value.
      *
-     * @param {mat2d} out the receiving vector
+     * @template {mat2d} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyMat2d} a the first operand
      * @param {ReadonlyMat2d} b the second operand
      * @param {Number} scale the amount to scale b's elements by before adding
-     * @returns {mat2d} out
+     * @returns {Mat2dResult<T>} out
      */
-    export function multiplyScalarAndAdd(out: mat2d, a: ReadonlyMat2d, b: ReadonlyMat2d, scale: number): mat2d;
+    export function multiplyScalarAndAdd<T extends mat2d>(out: T, a: ReadonlyMat2d, b: ReadonlyMat2d, scale: number): Mat2dResult<T>;
     /**
      * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
      *
@@ -600,21 +689,23 @@ export namespace mat2d {
     /**
      * Multiplies two mat2d's
      *
-     * @param {mat2d} out the receiving matrix
+     * @template {mat2d} T
+     * @param {T} out the receiving matrix
      * @param {ReadonlyMat2d} a the first operand
      * @param {ReadonlyMat2d} b the second operand
-     * @returns {mat2d} out
+     * @returns {Mat2dResult<T>} out
      */
-    export function mul(out: mat2d, a: ReadonlyMat2d, b: ReadonlyMat2d): mat2d;
+    export function mul<T extends mat2d>(out: T, a: ReadonlyMat2d, b: ReadonlyMat2d): Mat2dResult<T>;
     /**
      * Subtracts matrix b from matrix a
      *
-     * @param {mat2d} out the receiving matrix
+     * @template {mat2d} T
+     * @param {T} out the receiving matrix
      * @param {ReadonlyMat2d} a the first operand
      * @param {ReadonlyMat2d} b the second operand
-     * @returns {mat2d} out
+     * @returns {Mat2dResult<T>} out
      */
-    export function sub(out: mat2d, a: ReadonlyMat2d, b: ReadonlyMat2d): mat2d;
+    export function sub<T extends mat2d>(out: T, a: ReadonlyMat2d, b: ReadonlyMat2d): Mat2dResult<T>;
 }
 export namespace mat3 {
     /**
@@ -624,32 +715,34 @@ export namespace mat3 {
     /**
      * Creates a new identity mat3
      *
-     * @returns {mat3} a new 3x3 matrix
+     * @returns {mat3<DefaultArrayType>} a new 3x3 matrix
      */
-    export function create(): mat3;
+    export function create(): mat3<DefaultArrayType>;
     /**
      * Copies the upper-left 3x3 values into the given mat3.
      *
-     * @param {mat3} out the receiving 3x3 matrix
+     * @template {mat3} T
+     * @param {T} out the receiving 3x3 matrix
      * @param {ReadonlyMat4} a   the source 4x4 matrix
-     * @returns {mat3} out
+     * @returns {Mat3Result<T>} out
      */
-    export function fromMat4(out: mat3, a: ReadonlyMat4): mat3;
+    export function fromMat4<T extends mat3>(out: T, a: ReadonlyMat4): Mat3Result<T>;
     /**
      * Creates a new mat3 initialized with values from an existing matrix
      *
      * @param {ReadonlyMat3} a matrix to clone
-     * @returns {mat3} a new 3x3 matrix
+     * @returns {mat3<DefaultArrayType>} a new 3x3 matrix
      */
-    export function clone(a: ReadonlyMat3): mat3;
+    export function clone(a: ReadonlyMat3): mat3<DefaultArrayType>;
     /**
      * Copy the values from one mat3 to another
      *
-     * @param {mat3} out the receiving matrix
+     * @template {mat3} T
+     * @param {T} out the receiving matrix
      * @param {ReadonlyMat3} a the source matrix
-     * @returns {mat3} out
+     * @returns {Mat3Result<T>} out
      */
-    export function copy(out: mat3, a: ReadonlyMat3): mat3;
+    export function copy<T extends mat3>(out: T, a: ReadonlyMat3): Mat3Result<T>;
     /**
      * Create a new mat3 with the given values
      *
@@ -662,13 +755,14 @@ export namespace mat3 {
      * @param {Number} m20 Component in column 2, row 0 position (index 6)
      * @param {Number} m21 Component in column 2, row 1 position (index 7)
      * @param {Number} m22 Component in column 2, row 2 position (index 8)
-     * @returns {mat3} A new mat3
+     * @returns {mat3<DefaultArrayType>} A new mat3
      */
-    export function fromValues(m00: number, m01: number, m02: number, m10: number, m11: number, m12: number, m20: number, m21: number, m22: number): mat3;
+    export function fromValues(m00: number, m01: number, m02: number, m10: number, m11: number, m12: number, m20: number, m21: number, m22: number): mat3<DefaultArrayType>;
     /**
      * Set the components of a mat3 to the given values
      *
-     * @param {mat3} out the receiving matrix
+     * @template {mat3} T
+     * @param {T} out the receiving matrix
      * @param {Number} m00 Component in column 0, row 0 position (index 0)
      * @param {Number} m01 Component in column 0, row 1 position (index 1)
      * @param {Number} m02 Component in column 0, row 2 position (index 2)
@@ -678,40 +772,44 @@ export namespace mat3 {
      * @param {Number} m20 Component in column 2, row 0 position (index 6)
      * @param {Number} m21 Component in column 2, row 1 position (index 7)
      * @param {Number} m22 Component in column 2, row 2 position (index 8)
-     * @returns {mat3} out
+     * @returns {Mat3Result<T>} out
      */
-    export function set(out: mat3, m00: number, m01: number, m02: number, m10: number, m11: number, m12: number, m20: number, m21: number, m22: number): mat3;
+    export function set<T extends mat3>(out: T, m00: number, m01: number, m02: number, m10: number, m11: number, m12: number, m20: number, m21: number, m22: number): Mat3Result<T>;
     /**
      * Set a mat3 to the identity matrix
      *
-     * @param {mat3} out the receiving matrix
-     * @returns {mat3} out
+     * @template {mat3} T
+     * @param {T} out the receiving matrix
+     * @returns {Mat3Result<T>} out
      */
-    export function identity(out: mat3): mat3;
+    export function identity<T extends mat3>(out: T): Mat3Result<T>;
     /**
      * Transpose the values of a mat3
      *
-     * @param {mat3} out the receiving matrix
+     * @template {mat3} T
+     * @param {T} out the receiving matrix
      * @param {ReadonlyMat3} a the source matrix
-     * @returns {mat3} out
+     * @returns {Mat3Result<T>} out
      */
-    export function transpose(out: mat3, a: ReadonlyMat3): mat3;
+    export function transpose<T extends mat3>(out: T, a: ReadonlyMat3): Mat3Result<T>;
     /**
      * Inverts a mat3
      *
-     * @param {mat3} out the receiving matrix
+     * @template {mat3} T
+     * @param {T} out the receiving matrix
      * @param {ReadonlyMat3} a the source matrix
-     * @returns {mat3 | null} out, or null if source matrix is not invertible
+     * @returns {Mat3Result<T> | null} out, or null if source matrix is not invertible
      */
-    export function invert(out: mat3, a: ReadonlyMat3): mat3 | null;
+    export function invert<T extends mat3>(out: T, a: ReadonlyMat3): Mat3Result<T> | null;
     /**
      * Calculates the adjugate of a mat3
      *
-     * @param {mat3} out the receiving matrix
+     * @template {mat3} T
+     * @param {T} out the receiving matrix
      * @param {ReadonlyMat3} a the source matrix
-     * @returns {mat3} out
+     * @returns {Mat3Result<T>} out
      */
-    export function adjoint(out: mat3, a: ReadonlyMat3): mat3;
+    export function adjoint<T extends mat3>(out: T, a: ReadonlyMat3): Mat3Result<T>;
     /**
      * Calculates the determinant of a mat3
      *
@@ -722,39 +820,43 @@ export namespace mat3 {
     /**
      * Multiplies two mat3's
      *
-     * @param {mat3} out the receiving matrix
+     * @template {mat3} T
+     * @param {T} out the receiving matrix
      * @param {ReadonlyMat3} a the first operand
      * @param {ReadonlyMat3} b the second operand
-     * @returns {mat3} out
+     * @returns {Mat3Result<T>} out
      */
-    export function multiply(out: mat3, a: ReadonlyMat3, b: ReadonlyMat3): mat3;
+    export function multiply<T extends mat3>(out: T, a: ReadonlyMat3, b: ReadonlyMat3): Mat3Result<T>;
     /**
      * Translate a mat3 by the given vector
      *
-     * @param {mat3} out the receiving matrix
+     * @template {mat3} T
+     * @param {T} out the receiving matrix
      * @param {ReadonlyMat3} a the matrix to translate
      * @param {ReadonlyVec2} v vector to translate by
-     * @returns {mat3} out
+     * @returns {Mat3Result<T>} out
      */
-    export function translate(out: mat3, a: ReadonlyMat3, v: ReadonlyVec2): mat3;
+    export function translate<T extends mat3>(out: T, a: ReadonlyMat3, v: ReadonlyVec2): Mat3Result<T>;
     /**
      * Rotates a mat3 by the given angle
      *
-     * @param {mat3} out the receiving matrix
+     * @template {mat3} T
+     * @param {T} out the receiving matrix
      * @param {ReadonlyMat3} a the matrix to rotate
      * @param {Number} rad the angle to rotate the matrix by
-     * @returns {mat3} out
+     * @returns {Mat3Result<T>} out
      */
-    export function rotate(out: mat3, a: ReadonlyMat3, rad: number): mat3;
+    export function rotate<T extends mat3>(out: T, a: ReadonlyMat3, rad: number): Mat3Result<T>;
     /**
      * Scales the mat3 by the dimensions in the given vec2
      *
-     * @param {mat3} out the receiving matrix
+     * @template {mat3} T
+     * @param {T} out the receiving matrix
      * @param {ReadonlyMat3} a the matrix to scale
      * @param {ReadonlyVec2} v the vec2 to scale the matrix by
-     * @returns {mat3} out
+     * @returns {Mat3Result<T>} out
      **/
-    export function scale(out: mat3, a: ReadonlyMat3, v: ReadonlyVec2): mat3;
+    export function scale<T extends mat3>(out: T, a: ReadonlyMat3, v: ReadonlyVec2): Mat3Result<T>;
     /**
      * Creates a matrix from a vector translation
      * This is equivalent to (but much faster than):
@@ -762,11 +864,12 @@ export namespace mat3 {
      *     mat3.identity(dest);
      *     mat3.translate(dest, dest, vec);
      *
-     * @param {mat3} out mat3 receiving operation result
+     * @template {mat3} T
+     * @param {T} out mat3 receiving operation result
      * @param {ReadonlyVec2} v Translation vector
-     * @returns {mat3} out
+     * @returns {Mat3Result<T>} out
      */
-    export function fromTranslation(out: mat3, v: ReadonlyVec2): mat3;
+    export function fromTranslation<T extends mat3>(out: T, v: ReadonlyVec2): Mat3Result<T>;
     /**
      * Creates a matrix from a given angle
      * This is equivalent to (but much faster than):
@@ -774,11 +877,12 @@ export namespace mat3 {
      *     mat3.identity(dest);
      *     mat3.rotate(dest, dest, rad);
      *
-     * @param {mat3} out mat3 receiving operation result
+     * @template {mat3} T
+     * @param {T} out mat3 receiving operation result
      * @param {Number} rad the angle to rotate the matrix by
-     * @returns {mat3} out
+     * @returns {Mat3Result<T>} out
      */
-    export function fromRotation(out: mat3, rad: number): mat3;
+    export function fromRotation<T extends mat3>(out: T, rad: number): Mat3Result<T>;
     /**
      * Creates a matrix from a vector scaling
      * This is equivalent to (but much faster than):
@@ -786,46 +890,51 @@ export namespace mat3 {
      *     mat3.identity(dest);
      *     mat3.scale(dest, dest, vec);
      *
-     * @param {mat3} out mat3 receiving operation result
+     * @template {mat3} T
+     * @param {T} out mat3 receiving operation result
      * @param {ReadonlyVec2} v Scaling vector
-     * @returns {mat3} out
+     * @returns {Mat3Result<T>} out
      */
-    export function fromScaling(out: mat3, v: ReadonlyVec2): mat3;
+    export function fromScaling<T extends mat3>(out: T, v: ReadonlyVec2): Mat3Result<T>;
     /**
      * Copies the values from a mat2d into a mat3
      *
-     * @param {mat3} out the receiving matrix
+     * @template {mat3} T
+     * @param {T} out the receiving matrix
      * @param {ReadonlyMat2d} a the matrix to copy
-     * @returns {mat3} out
+     * @returns {Mat3Result<T>} out
      **/
-    export function fromMat2d(out: mat3, a: ReadonlyMat2d): mat3;
+    export function fromMat2d<T extends mat3>(out: T, a: ReadonlyMat2d): Mat3Result<T>;
     /**
      * Calculates a 3x3 matrix from the given quaternion
      *
-     * @param {mat3} out mat3 receiving operation result
+     * @template {mat3} T
+     * @param {T} out mat3 receiving operation result
      * @param {ReadonlyQuat} q Quaternion to create matrix from
      *
-     * @returns {mat3} out
+     * @returns {Mat3Result<T>} out
      */
-    export function fromQuat(out: mat3, q: ReadonlyQuat): mat3;
+    export function fromQuat<T extends mat3>(out: T, q: ReadonlyQuat): Mat3Result<T>;
     /**
      * Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
      *
-     * @param {mat3} out mat3 receiving operation result
+     * @template {mat3} T
+     * @param {T} out mat3 receiving operation result
      * @param {ReadonlyMat4} a Mat4 to derive the normal matrix from
      *
-     * @returns {mat3} out
+     * @returns {Mat3Result<T>} out
      */
-    export function normalFromMat4(out: mat3, a: ReadonlyMat4): mat3;
+    export function normalFromMat4<T extends mat3>(out: T, a: ReadonlyMat4): Mat3Result<T>;
     /**
      * Generates a 2D projection matrix with the given bounds
      *
-     * @param {mat3} out mat3 frustum matrix will be written into
+     * @template {mat3} T
+     * @param {T} out mat3 frustum matrix will be written into
      * @param {number} width Width of your gl context
      * @param {number} height Height of gl context
-     * @returns {mat3} out
+     * @returns {Mat3Result<T>} out
      */
-    export function projection(out: mat3, width: number, height: number): mat3;
+    export function projection<T extends mat3>(out: T, width: number, height: number): Mat3Result<T>;
     /**
      * Returns a string representation of a mat3
      *
@@ -843,40 +952,44 @@ export namespace mat3 {
     /**
      * Adds two mat3's
      *
-     * @param {mat3} out the receiving matrix
+     * @template {mat3} T
+     * @param {T} out the receiving matrix
      * @param {ReadonlyMat3} a the first operand
      * @param {ReadonlyMat3} b the second operand
-     * @returns {mat3} out
+     * @returns {Mat3Result<T>} out
      */
-    export function add(out: mat3, a: ReadonlyMat3, b: ReadonlyMat3): mat3;
+    export function add<T extends mat3>(out: T, a: ReadonlyMat3, b: ReadonlyMat3): Mat3Result<T>;
     /**
      * Subtracts matrix b from matrix a
      *
-     * @param {mat3} out the receiving matrix
+     * @template {mat3} T
+     * @param {T} out the receiving matrix
      * @param {ReadonlyMat3} a the first operand
      * @param {ReadonlyMat3} b the second operand
-     * @returns {mat3} out
+     * @returns {Mat3Result<T>} out
      */
-    export function subtract(out: mat3, a: ReadonlyMat3, b: ReadonlyMat3): mat3;
+    export function subtract<T extends mat3>(out: T, a: ReadonlyMat3, b: ReadonlyMat3): Mat3Result<T>;
     /**
      * Multiply each element of the matrix by a scalar.
      *
-     * @param {mat3} out the receiving matrix
+     * @template {mat3} T
+     * @param {T} out the receiving matrix
      * @param {ReadonlyMat3} a the matrix to scale
      * @param {Number} b amount to scale the matrix's elements by
-     * @returns {mat3} out
+     * @returns {Mat3Result<T>} out
      */
-    export function multiplyScalar(out: mat3, a: ReadonlyMat3, b: number): mat3;
+    export function multiplyScalar<T extends mat3>(out: T, a: ReadonlyMat3, b: number): Mat3Result<T>;
     /**
      * Adds two mat3's after multiplying each element of the second operand by a scalar value.
      *
-     * @param {mat3} out the receiving vector
+     * @template {mat3} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyMat3} a the first operand
      * @param {ReadonlyMat3} b the second operand
      * @param {Number} scale the amount to scale b's elements by before adding
-     * @returns {mat3} out
+     * @returns {Mat3Result<T>} out
      */
-    export function multiplyScalarAndAdd(out: mat3, a: ReadonlyMat3, b: ReadonlyMat3, scale: number): mat3;
+    export function multiplyScalarAndAdd<T extends mat3>(out: T, a: ReadonlyMat3, b: ReadonlyMat3, scale: number): Mat3Result<T>;
     /**
      * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
      *
@@ -896,21 +1009,23 @@ export namespace mat3 {
     /**
      * Multiplies two mat3's
      *
-     * @param {mat3} out the receiving matrix
+     * @template {mat3} T
+     * @param {T} out the receiving matrix
      * @param {ReadonlyMat3} a the first operand
      * @param {ReadonlyMat3} b the second operand
-     * @returns {mat3} out
+     * @returns {Mat3Result<T>} out
      */
-    export function mul(out: mat3, a: ReadonlyMat3, b: ReadonlyMat3): mat3;
+    export function mul<T extends mat3>(out: T, a: ReadonlyMat3, b: ReadonlyMat3): Mat3Result<T>;
     /**
      * Subtracts matrix b from matrix a
      *
-     * @param {mat3} out the receiving matrix
+     * @template {mat3} T
+     * @param {T} out the receiving matrix
      * @param {ReadonlyMat3} a the first operand
      * @param {ReadonlyMat3} b the second operand
-     * @returns {mat3} out
+     * @returns {Mat3Result<T>} out
      */
-    export function sub(out: mat3, a: ReadonlyMat3, b: ReadonlyMat3): mat3;
+    export function sub<T extends mat3>(out: T, a: ReadonlyMat3, b: ReadonlyMat3): Mat3Result<T>;
 }
 export namespace mat4 {
     /**
@@ -920,24 +1035,25 @@ export namespace mat4 {
     /**
      * Creates a new identity mat4
      *
-     * @returns {mat4} a new 4x4 matrix
+     * @returns {mat4<DefaultArrayType>} a new 4x4 matrix
      */
-    export function create(): mat4;
+    export function create(): mat4<DefaultArrayType>;
     /**
      * Creates a new mat4 initialized with values from an existing matrix
      *
      * @param {ReadonlyMat4} a matrix to clone
-     * @returns {mat4} a new 4x4 matrix
+     * @returns {mat4<DefaultArrayType>} a new 4x4 matrix
      */
-    export function clone(a: ReadonlyMat4): mat4;
+    export function clone(a: ReadonlyMat4): mat4<DefaultArrayType>;
     /**
      * Copy the values from one mat4 to another
      *
-     * @param {mat4} out the receiving matrix
+     * @template {mat4} T
+     * @param {T} out the receiving matrix
      * @param {ReadonlyMat4} a the source matrix
-     * @returns {mat4} out
+     * @returns {Mat4Result<T>} out
      */
-    export function copy(out: mat4, a: ReadonlyMat4): mat4;
+    export function copy<T extends mat4>(out: T, a: ReadonlyMat4): Mat4Result<T>;
     /**
      * Create a new mat4 with the given values
      *
@@ -957,13 +1073,14 @@ export namespace mat4 {
      * @param {Number} m31 Component in column 3, row 1 position (index 13)
      * @param {Number} m32 Component in column 3, row 2 position (index 14)
      * @param {Number} m33 Component in column 3, row 3 position (index 15)
-     * @returns {mat4} A new mat4
+     * @returns {mat4<DefaultArrayType>} A new mat4
      */
-    export function fromValues(m00: number, m01: number, m02: number, m03: number, m10: number, m11: number, m12: number, m13: number, m20: number, m21: number, m22: number, m23: number, m30: number, m31: number, m32: number, m33: number): mat4;
+    export function fromValues(m00: number, m01: number, m02: number, m03: number, m10: number, m11: number, m12: number, m13: number, m20: number, m21: number, m22: number, m23: number, m30: number, m31: number, m32: number, m33: number): mat4<DefaultArrayType>;
     /**
      * Set the components of a mat4 to the given values
      *
-     * @param {mat4} out the receiving matrix
+     * @template {mat4} T
+     * @param {T} out the receiving matrix
      * @param {Number} m00 Component in column 0, row 0 position (index 0)
      * @param {Number} m01 Component in column 0, row 1 position (index 1)
      * @param {Number} m02 Component in column 0, row 2 position (index 2)
@@ -980,40 +1097,44 @@ export namespace mat4 {
      * @param {Number} m31 Component in column 3, row 1 position (index 13)
      * @param {Number} m32 Component in column 3, row 2 position (index 14)
      * @param {Number} m33 Component in column 3, row 3 position (index 15)
-     * @returns {mat4} out
+     * @returns {Mat4Result<T>} out
      */
-    export function set(out: mat4, m00: number, m01: number, m02: number, m03: number, m10: number, m11: number, m12: number, m13: number, m20: number, m21: number, m22: number, m23: number, m30: number, m31: number, m32: number, m33: number): mat4;
+    export function set<T extends mat4>(out: T, m00: number, m01: number, m02: number, m03: number, m10: number, m11: number, m12: number, m13: number, m20: number, m21: number, m22: number, m23: number, m30: number, m31: number, m32: number, m33: number): Mat4Result<T>;
     /**
      * Set a mat4 to the identity matrix
      *
-     * @param {mat4} out the receiving matrix
-     * @returns {mat4} out
+     * @template {mat4} T
+     * @param {T} out the receiving matrix
+     * @returns {Mat4Result<T>} out
      */
-    export function identity(out: mat4): mat4;
+    export function identity<T extends mat4>(out: T): Mat4Result<T>;
     /**
      * Transpose the values of a mat4
      *
-     * @param {mat4} out the receiving matrix
+     * @template {mat4} T
+     * @param {T} out the receiving matrix
      * @param {ReadonlyMat4} a the source matrix
-     * @returns {mat4} out
+     * @returns {Mat4Result<T>} out
      */
-    export function transpose(out: mat4, a: ReadonlyMat4): mat4;
+    export function transpose<T extends mat4>(out: T, a: ReadonlyMat4): Mat4Result<T>;
     /**
      * Inverts a mat4
      *
-     * @param {mat4} out the receiving matrix
+     * @template {mat4} T
+     * @param {T} out the receiving matrix
      * @param {ReadonlyMat4} a the source matrix
-     * @returns {mat4 | null} out, or null if source matrix is not invertible
+     * @returns {Mat4Result<T> | null} out, or null if source matrix is not invertible
      */
-    export function invert(out: mat4, a: ReadonlyMat4): mat4 | null;
+    export function invert<T extends mat4>(out: T, a: ReadonlyMat4): Mat4Result<T> | null;
     /**
      * Calculates the adjugate of a mat4
      *
-     * @param {mat4} out the receiving matrix
+     * @template {mat4} T
+     * @param {T} out the receiving matrix
      * @param {ReadonlyMat4} a the source matrix
-     * @returns {mat4} out
+     * @returns {Mat4Result<T>} out
      */
-    export function adjoint(out: mat4, a: ReadonlyMat4): mat4;
+    export function adjoint<T extends mat4>(out: T, a: ReadonlyMat4): Mat4Result<T>;
     /**
      * Calculates the determinant of a mat4
      *
@@ -1024,67 +1145,74 @@ export namespace mat4 {
     /**
      * Multiplies two mat4s
      *
-     * @param {mat4} out the receiving matrix
+     * @template {mat4} T
+     * @param {T} out the receiving matrix
      * @param {ReadonlyMat4} a the first operand
      * @param {ReadonlyMat4} b the second operand
-     * @returns {mat4} out
+     * @returns {Mat4Result<T>} out
      */
-    export function multiply(out: mat4, a: ReadonlyMat4, b: ReadonlyMat4): mat4;
+    export function multiply<T extends mat4>(out: T, a: ReadonlyMat4, b: ReadonlyMat4): Mat4Result<T>;
     /**
      * Translate a mat4 by the given vector
      *
-     * @param {mat4} out the receiving matrix
+     * @template {mat4} T
+     * @param {T} out the receiving matrix
      * @param {ReadonlyMat4} a the matrix to translate
      * @param {ReadonlyVec3} v vector to translate by
-     * @returns {mat4} out
+     * @returns {Mat4Result<T>} out
      */
-    export function translate(out: mat4, a: ReadonlyMat4, v: ReadonlyVec3): mat4;
+    export function translate<T extends mat4>(out: T, a: ReadonlyMat4, v: ReadonlyVec3): Mat4Result<T>;
     /**
      * Scales the mat4 by the dimensions in the given vec3 not using vectorization
      *
-     * @param {mat4} out the receiving matrix
+     * @template {mat4} T
+     * @param {T} out the receiving matrix
      * @param {ReadonlyMat4} a the matrix to scale
      * @param {ReadonlyVec3} v the vec3 to scale the matrix by
-     * @returns {mat4} out
+     * @returns {Mat4Result<T>} out
      **/
-    export function scale(out: mat4, a: ReadonlyMat4, v: ReadonlyVec3): mat4;
+    export function scale<T extends mat4>(out: T, a: ReadonlyMat4, v: ReadonlyVec3): Mat4Result<T>;
     /**
      * Rotates a mat4 by the given angle around the given axis
      *
-     * @param {mat4} out the receiving matrix
+     * @template {mat4} T
+     * @param {T} out the receiving matrix
      * @param {ReadonlyMat4} a the matrix to rotate
      * @param {Number} rad the angle to rotate the matrix by
      * @param {ReadonlyVec3} axis the axis to rotate around
-     * @returns {mat4} out
+     * @returns {Mat4Result<T>} out
      */
-    export function rotate(out: mat4, a: ReadonlyMat4, rad: number, axis: ReadonlyVec3): mat4;
+    export function rotate<T extends mat4>(out: T, a: ReadonlyMat4, rad: number, axis: ReadonlyVec3): Mat4Result<T>;
     /**
      * Rotates a matrix by the given angle around the X axis
      *
-     * @param {mat4} out the receiving matrix
+     * @template {mat4} T
+     * @param {T} out the receiving matrix
      * @param {ReadonlyMat4} a the matrix to rotate
      * @param {Number} rad the angle to rotate the matrix by
-     * @returns {mat4} out
+     * @returns {Mat4Result<T>} out
      */
-    export function rotateX(out: mat4, a: ReadonlyMat4, rad: number): mat4;
+    export function rotateX<T extends mat4>(out: T, a: ReadonlyMat4, rad: number): Mat4Result<T>;
     /**
      * Rotates a matrix by the given angle around the Y axis
      *
-     * @param {mat4} out the receiving matrix
+     * @template {mat4} T
+     * @param {T} out the receiving matrix
      * @param {ReadonlyMat4} a the matrix to rotate
      * @param {Number} rad the angle to rotate the matrix by
-     * @returns {mat4} out
+     * @returns {Mat4Result<T>} out
      */
-    export function rotateY(out: mat4, a: ReadonlyMat4, rad: number): mat4;
+    export function rotateY<T extends mat4>(out: T, a: ReadonlyMat4, rad: number): Mat4Result<T>;
     /**
      * Rotates a matrix by the given angle around the Z axis
      *
-     * @param {mat4} out the receiving matrix
+     * @template {mat4} T
+     * @param {T} out the receiving matrix
      * @param {ReadonlyMat4} a the matrix to rotate
      * @param {Number} rad the angle to rotate the matrix by
-     * @returns {mat4} out
+     * @returns {Mat4Result<T>} out
      */
-    export function rotateZ(out: mat4, a: ReadonlyMat4, rad: number): mat4;
+    export function rotateZ<T extends mat4>(out: T, a: ReadonlyMat4, rad: number): Mat4Result<T>;
     /**
      * Creates a matrix from a vector translation
      * This is equivalent to (but much faster than):
@@ -1092,11 +1220,12 @@ export namespace mat4 {
      *     mat4.identity(dest);
      *     mat4.translate(dest, dest, vec);
      *
-     * @param {mat4} out mat4 receiving operation result
+     * @template {mat4} T
+     * @param {T} out mat4 receiving operation result
      * @param {ReadonlyVec3} v Translation vector
-     * @returns {mat4} out
+     * @returns {Mat4Result<T>} out
      */
-    export function fromTranslation(out: mat4, v: ReadonlyVec3): mat4;
+    export function fromTranslation<T extends mat4>(out: T, v: ReadonlyVec3): Mat4Result<T>;
     /**
      * Creates a matrix from a vector scaling
      * This is equivalent to (but much faster than):
@@ -1104,11 +1233,12 @@ export namespace mat4 {
      *     mat4.identity(dest);
      *     mat4.scale(dest, dest, vec);
      *
-     * @param {mat4} out mat4 receiving operation result
+     * @template {mat4} T
+     * @param {T} out mat4 receiving operation result
      * @param {ReadonlyVec3} v Scaling vector
-     * @returns {mat4} out
+     * @returns {Mat4Result<T>} out
      */
-    export function fromScaling(out: mat4, v: ReadonlyVec3): mat4;
+    export function fromScaling<T extends mat4>(out: T, v: ReadonlyVec3): Mat4Result<T>;
     /**
      * Creates a matrix from a given angle around a given axis
      * This is equivalent to (but much faster than):
@@ -1116,12 +1246,13 @@ export namespace mat4 {
      *     mat4.identity(dest);
      *     mat4.rotate(dest, dest, rad, axis);
      *
-     * @param {mat4} out mat4 receiving operation result
+     * @template {mat4} T
+     * @param {T} out mat4 receiving operation result
      * @param {Number} rad the angle to rotate the matrix by
      * @param {ReadonlyVec3} axis the axis to rotate around
-     * @returns {mat4} out
+     * @returns {Mat4Result<T>} out
      */
-    export function fromRotation(out: mat4, rad: number, axis: ReadonlyVec3): mat4;
+    export function fromRotation<T extends mat4>(out: T, rad: number, axis: ReadonlyVec3): Mat4Result<T>;
     /**
      * Creates a matrix from the given angle around the X axis
      * This is equivalent to (but much faster than):
@@ -1129,11 +1260,12 @@ export namespace mat4 {
      *     mat4.identity(dest);
      *     mat4.rotateX(dest, dest, rad);
      *
-     * @param {mat4} out mat4 receiving operation result
+     * @template {mat4} T
+     * @param {T} out mat4 receiving operation result
      * @param {Number} rad the angle to rotate the matrix by
-     * @returns {mat4} out
+     * @returns {Mat4Result<T>} out
      */
-    export function fromXRotation(out: mat4, rad: number): mat4;
+    export function fromXRotation<T extends mat4>(out: T, rad: number): Mat4Result<T>;
     /**
      * Creates a matrix from the given angle around the Y axis
      * This is equivalent to (but much faster than):
@@ -1141,11 +1273,12 @@ export namespace mat4 {
      *     mat4.identity(dest);
      *     mat4.rotateY(dest, dest, rad);
      *
-     * @param {mat4} out mat4 receiving operation result
+     * @template {mat4} T
+     * @param {T} out mat4 receiving operation result
      * @param {Number} rad the angle to rotate the matrix by
-     * @returns {mat4} out
+     * @returns {Mat4Result<T>} out
      */
-    export function fromYRotation(out: mat4, rad: number): mat4;
+    export function fromYRotation<T extends mat4>(out: T, rad: number): Mat4Result<T>;
     /**
      * Creates a matrix from the given angle around the Z axis
      * This is equivalent to (but much faster than):
@@ -1153,11 +1286,12 @@ export namespace mat4 {
      *     mat4.identity(dest);
      *     mat4.rotateZ(dest, dest, rad);
      *
-     * @param {mat4} out mat4 receiving operation result
+     * @template {mat4} T
+     * @param {T} out mat4 receiving operation result
      * @param {Number} rad the angle to rotate the matrix by
-     * @returns {mat4} out
+     * @returns {Mat4Result<T>} out
      */
-    export function fromZRotation(out: mat4, rad: number): mat4;
+    export function fromZRotation<T extends mat4>(out: T, rad: number): Mat4Result<T>;
     /**
      * Creates a matrix from a quaternion rotation and vector translation
      * This is equivalent to (but much faster than):
@@ -1168,20 +1302,21 @@ export namespace mat4 {
      *     mat4.fromQuat(quatMat, quat);
      *     mat4.multiply(dest, dest, quatMat);
      *
-     * @param {mat4} out mat4 receiving operation result
+     * @template {mat4} T
+     * @param {T} out mat4 receiving operation result
      * @param {quat} q Rotation quaternion
      * @param {ReadonlyVec3} v Translation vector
-     * @returns {mat4} out
+     * @returns {Mat4Result<T>} out
      */
-    export function fromRotationTranslation(out: mat4, q: quat, v: ReadonlyVec3): mat4;
+    export function fromRotationTranslation<T extends mat4>(out: T, q: quat, v: ReadonlyVec3): Mat4Result<T>;
     /**
      * Creates a new mat4 from a dual quat.
      *
      * @param {mat4} out Matrix
      * @param {ReadonlyQuat2} a Dual Quaternion
-     * @returns {mat4} mat4 receiving operation result
+     * @returns {mat4<DefaultArrayType>} mat4 receiving operation result
      */
-    export function fromQuat2(out: mat4, a: ReadonlyQuat2): mat4;
+    export function fromQuat2(out: mat4, a: ReadonlyQuat2): mat4<DefaultArrayType>;
     /**
      * Returns the translation vector component of a transformation
      *  matrix. If a matrix is built with fromRotationTranslation,
@@ -1216,13 +1351,14 @@ export namespace mat4 {
     /**
      * Decomposes a transformation matrix into its rotation, translation
      * and scale components. Returns only the rotation component
+     *
      * @param  {quat} out_r Quaternion to receive the rotation component
      * @param  {vec3} out_t Vector to receive the translation vector
      * @param  {vec3} out_s Vector to receive the scaling factor
      * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
-     * @returns {quat} out_r
+     * @returns {quat<DefaultArrayType>} out_r
      */
-    export function decompose(out_r: quat, out_t: vec3, out_s: vec3, mat: ReadonlyMat4): quat;
+    export function decompose(out_r: quat, out_t: vec3, out_s: vec3, mat: ReadonlyMat4): quat<DefaultArrayType>;
     /**
      * Creates a matrix from a quaternion rotation, vector translation and vector scale
      * This is equivalent to (but much faster than):
@@ -1234,13 +1370,14 @@ export namespace mat4 {
      *     mat4.multiply(dest, dest, quatMat);
      *     mat4.scale(dest, dest, scale)
      *
-     * @param {mat4} out mat4 receiving operation result
+     * @template {mat4} T
+     * @param {T} out mat4 receiving operation result
      * @param {quat} q Rotation quaternion
      * @param {ReadonlyVec3} v Translation vector
      * @param {ReadonlyVec3} s Scaling vector
-     * @returns {mat4} out
+     * @returns {Mat4Result<T>} out
      */
-    export function fromRotationTranslationScale(out: mat4, q: quat, v: ReadonlyVec3, s: ReadonlyVec3): mat4;
+    export function fromRotationTranslationScale<T extends mat4>(out: T, q: quat, v: ReadonlyVec3, s: ReadonlyVec3): Mat4Result<T>;
     /**
      * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
      * This is equivalent to (but much faster than):
@@ -1254,26 +1391,29 @@ export namespace mat4 {
      *     mat4.scale(dest, dest, scale)
      *     mat4.translate(dest, dest, negativeOrigin);
      *
-     * @param {mat4} out mat4 receiving operation result
+     * @template {mat4} T
+     * @param {T} out mat4 receiving operation result
      * @param {quat} q Rotation quaternion
      * @param {ReadonlyVec3} v Translation vector
      * @param {ReadonlyVec3} s Scaling vector
      * @param {ReadonlyVec3} o The origin vector around which to scale and rotate
-     * @returns {mat4} out
+     * @returns {Mat4Result<T>} out
      */
-    export function fromRotationTranslationScaleOrigin(out: mat4, q: quat, v: ReadonlyVec3, s: ReadonlyVec3, o: ReadonlyVec3): mat4;
+    export function fromRotationTranslationScaleOrigin<T extends mat4>(out: T, q: quat, v: ReadonlyVec3, s: ReadonlyVec3, o: ReadonlyVec3): Mat4Result<T>;
     /**
      * Calculates a 4x4 matrix from the given quaternion
      *
-     * @param {mat4} out mat4 receiving operation result
+     * @template {mat4} T
+     * @param {T} out mat4 receiving operation result
      * @param {ReadonlyQuat} q Quaternion to create matrix from
      *
-     * @returns {mat4} out
+     * @returns {Mat4Result<T>} out
      */
-    export function fromQuat(out: mat4, q: ReadonlyQuat): mat4;
+    export function fromQuat<T extends mat4>(out: T, q: ReadonlyQuat): Mat4Result<T>;
     /**
      * Generates a frustum matrix with the given bounds
      *
+     * @template {mat4} T
      * @param {mat4} out mat4 frustum matrix will be written into
      * @param {Number} left Left bound of the frustum
      * @param {Number} right Right bound of the frustum
@@ -1281,54 +1421,58 @@ export namespace mat4 {
      * @param {Number} top Top bound of the frustum
      * @param {Number} near Near bound of the frustum
      * @param {Number} far Far bound of the frustum
-     * @returns {mat4} out
+     * @returns {Mat4Result<T>} out
      */
-    export function frustum(out: mat4, left: number, right: number, bottom: number, top: number, near: number, far: number): mat4;
+    export function frustum<T extends mat4>(out: mat4, left: number, right: number, bottom: number, top: number, near: number, far: number): Mat4Result<T>;
     /**
      * Generates a perspective projection matrix with the given bounds.
      * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],
      * which matches WebGL/OpenGL's clip volume.
      * Passing null/undefined/no value for far will generate infinite projection matrix.
      *
-     * @param {mat4} out mat4 frustum matrix will be written into
+     * @template {mat4} T
+     * @param {T} out mat4 frustum matrix will be written into
      * @param {number} fovy Vertical field of view in radians
      * @param {number} aspect Aspect ratio. typically viewport width/height
      * @param {number} near Near bound of the frustum
      * @param {number} far Far bound of the frustum, can be null or Infinity
-     * @returns {mat4} out
+     * @returns {Mat4Result<T>} out
      */
-    export function perspectiveNO(out: mat4, fovy: number, aspect: number, near: number, far: number): mat4;
+    export function perspectiveNO<T extends mat4>(out: T, fovy: number, aspect: number, near: number, far: number): Mat4Result<T>;
     /**
      * Generates a perspective projection matrix suitable for WebGPU with the given bounds.
      * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],
      * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.
      * Passing null/undefined/no value for far will generate infinite projection matrix.
      *
+     * @template {mat4} T
      * @param {mat4} out mat4 frustum matrix will be written into
      * @param {number} fovy Vertical field of view in radians
      * @param {number} aspect Aspect ratio. typically viewport width/height
      * @param {number} near Near bound of the frustum
      * @param {number} far Far bound of the frustum, can be null or Infinity
-     * @returns {mat4} out
+     * @returns {Mat4Result<T>} out
      */
-    export function perspectiveZO(out: mat4, fovy: number, aspect: number, near: number, far: number): mat4;
+    export function perspectiveZO<T extends mat4>(out: mat4, fovy: number, aspect: number, near: number, far: number): Mat4Result<T>;
     /**
      * Generates a perspective projection matrix with the given field of view.
      * This is primarily useful for generating projection matrices to be used
      * with the still experiemental WebVR API.
      *
+     * @template {mat4} T
      * @param {mat4} out mat4 frustum matrix will be written into
      * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
      * @param {number} near Near bound of the frustum
      * @param {number} far Far bound of the frustum
-     * @returns {mat4} out
+     * @returns {Mat4Result<T>} out
      */
-    export function perspectiveFromFieldOfView(out: mat4, fov: any, near: number, far: number): mat4;
+    export function perspectiveFromFieldOfView<T extends mat4>(out: mat4, fov: any, near: number, far: number): Mat4Result<T>;
     /**
      * Generates a orthogonal projection matrix with the given bounds.
      * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],
      * which matches WebGL/OpenGL's clip volume.
      *
+     * @template {mat4} T
      * @param {mat4} out mat4 frustum matrix will be written into
      * @param {number} left Left bound of the frustum
      * @param {number} right Right bound of the frustum
@@ -1336,14 +1480,15 @@ export namespace mat4 {
      * @param {number} top Top bound of the frustum
      * @param {number} near Near bound of the frustum
      * @param {number} far Far bound of the frustum
-     * @returns {mat4} out
+     * @returns {Mat4Result<T>} out
      */
-    export function orthoNO(out: mat4, left: number, right: number, bottom: number, top: number, near: number, far: number): mat4;
+    export function orthoNO<T extends mat4>(out: mat4, left: number, right: number, bottom: number, top: number, near: number, far: number): Mat4Result<T>;
     /**
      * Generates a orthogonal projection matrix with the given bounds.
      * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],
      * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.
      *
+     * @template {mat4} T
      * @param {mat4} out mat4 frustum matrix will be written into
      * @param {number} left Left bound of the frustum
      * @param {number} right Right bound of the frustum
@@ -1351,30 +1496,32 @@ export namespace mat4 {
      * @param {number} top Top bound of the frustum
      * @param {number} near Near bound of the frustum
      * @param {number} far Far bound of the frustum
-     * @returns {mat4} out
+     * @returns {Mat4Result<T>} out
      */
-    export function orthoZO(out: mat4, left: number, right: number, bottom: number, top: number, near: number, far: number): mat4;
+    export function orthoZO<T extends mat4>(out: mat4, left: number, right: number, bottom: number, top: number, near: number, far: number): Mat4Result<T>;
     /**
      * Generates a look-at matrix with the given eye position, focal point, and up axis.
      * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.
      *
+     * @template {mat4} T
      * @param {mat4} out mat4 frustum matrix will be written into
      * @param {ReadonlyVec3} eye Position of the viewer
      * @param {ReadonlyVec3} center Point the viewer is looking at
      * @param {ReadonlyVec3} up vec3 pointing up
-     * @returns {mat4} out
+     * @returns {Mat4Result<T>} out
      */
-    export function lookAt(out: mat4, eye: ReadonlyVec3, center: ReadonlyVec3, up: ReadonlyVec3): mat4;
+    export function lookAt<T extends mat4>(out: mat4, eye: ReadonlyVec3, center: ReadonlyVec3, up: ReadonlyVec3): Mat4Result<T>;
     /**
      * Generates a matrix that makes something look at something else.
      *
+     * @template {mat4} T
      * @param {mat4} out mat4 frustum matrix will be written into
      * @param {ReadonlyVec3} eye Position of the viewer
      * @param {ReadonlyVec3} target Point the viewer is looking at
      * @param {ReadonlyVec3} up vec3 pointing up
-     * @returns {mat4} out
+     * @returns {Mat4Result<T>} out
      */
-    export function targetTo(out: mat4, eye: ReadonlyVec3, target: ReadonlyVec3, up: ReadonlyVec3): mat4;
+    export function targetTo<T extends mat4>(out: mat4, eye: ReadonlyVec3, target: ReadonlyVec3, up: ReadonlyVec3): Mat4Result<T>;
     /**
      * Returns a string representation of a mat4
      *
@@ -1392,40 +1539,44 @@ export namespace mat4 {
     /**
      * Adds two mat4's
      *
-     * @param {mat4} out the receiving matrix
+     * @template {mat4} T
+     * @param {T} out the receiving matrix
      * @param {ReadonlyMat4} a the first operand
      * @param {ReadonlyMat4} b the second operand
-     * @returns {mat4} out
+     * @returns {Mat4Result<T>} out
      */
-    export function add(out: mat4, a: ReadonlyMat4, b: ReadonlyMat4): mat4;
+    export function add<T extends mat4>(out: T, a: ReadonlyMat4, b: ReadonlyMat4): Mat4Result<T>;
     /**
      * Subtracts matrix b from matrix a
      *
-     * @param {mat4} out the receiving matrix
+     * @template {mat4} T
+     * @param {T} out the receiving matrix
      * @param {ReadonlyMat4} a the first operand
      * @param {ReadonlyMat4} b the second operand
-     * @returns {mat4} out
+     * @returns {Mat4Result<T>} out
      */
-    export function subtract(out: mat4, a: ReadonlyMat4, b: ReadonlyMat4): mat4;
+    export function subtract<T extends mat4>(out: T, a: ReadonlyMat4, b: ReadonlyMat4): Mat4Result<T>;
     /**
      * Multiply each element of the matrix by a scalar.
      *
-     * @param {mat4} out the receiving matrix
+     * @template {mat4} T
+     * @param {T} out the receiving matrix
      * @param {ReadonlyMat4} a the matrix to scale
      * @param {Number} b amount to scale the matrix's elements by
-     * @returns {mat4} out
+     * @returns {Mat4Result<T>} out
      */
-    export function multiplyScalar(out: mat4, a: ReadonlyMat4, b: number): mat4;
+    export function multiplyScalar<T extends mat4>(out: T, a: ReadonlyMat4, b: number): Mat4Result<T>;
     /**
      * Adds two mat4's after multiplying each element of the second operand by a scalar value.
      *
-     * @param {mat4} out the receiving vector
+     * @template {mat4} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyMat4} a the first operand
      * @param {ReadonlyMat4} b the second operand
      * @param {Number} scale the amount to scale b's elements by before adding
-     * @returns {mat4} out
+     * @returns {Mat4Result<T>} out
      */
-    export function multiplyScalarAndAdd(out: mat4, a: ReadonlyMat4, b: ReadonlyMat4, scale: number): mat4;
+    export function multiplyScalarAndAdd<T extends mat4>(out: T, a: ReadonlyMat4, b: ReadonlyMat4, scale: number): Mat4Result<T>;
     /**
      * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
      *
@@ -1448,19 +1599,21 @@ export namespace mat4 {
      * which matches WebGL/OpenGL's clip volume.
      * Passing null/undefined/no value for far will generate infinite projection matrix.
      *
-     * @param {mat4} out mat4 frustum matrix will be written into
+     * @template {mat4} T
+     * @param {T} out mat4 frustum matrix will be written into
      * @param {number} fovy Vertical field of view in radians
      * @param {number} aspect Aspect ratio. typically viewport width/height
      * @param {number} near Near bound of the frustum
      * @param {number} far Far bound of the frustum, can be null or Infinity
-     * @returns {mat4} out
+     * @returns {Mat4Result<T>} out
      */
-    export function perspective(out: mat4, fovy: number, aspect: number, near: number, far: number): mat4;
+    export function perspective<T extends mat4>(out: T, fovy: number, aspect: number, near: number, far: number): Mat4Result<T>;
     /**
      * Generates a orthogonal projection matrix with the given bounds.
      * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],
      * which matches WebGL/OpenGL's clip volume.
      *
+     * @template {mat4} T
      * @param {mat4} out mat4 frustum matrix will be written into
      * @param {number} left Left bound of the frustum
      * @param {number} right Right bound of the frustum
@@ -1468,27 +1621,29 @@ export namespace mat4 {
      * @param {number} top Top bound of the frustum
      * @param {number} near Near bound of the frustum
      * @param {number} far Far bound of the frustum
-     * @returns {mat4} out
+     * @returns {Mat4Result<T>} out
      */
-    export function ortho(out: mat4, left: number, right: number, bottom: number, top: number, near: number, far: number): mat4;
+    export function ortho<T extends mat4>(out: mat4, left: number, right: number, bottom: number, top: number, near: number, far: number): Mat4Result<T>;
     /**
      * Multiplies two mat4s
      *
-     * @param {mat4} out the receiving matrix
+     * @template {mat4} T
+     * @param {T} out the receiving matrix
      * @param {ReadonlyMat4} a the first operand
      * @param {ReadonlyMat4} b the second operand
-     * @returns {mat4} out
+     * @returns {Mat4Result<T>} out
      */
-    export function mul(out: mat4, a: ReadonlyMat4, b: ReadonlyMat4): mat4;
+    export function mul<T extends mat4>(out: T, a: ReadonlyMat4, b: ReadonlyMat4): Mat4Result<T>;
     /**
      * Subtracts matrix b from matrix a
      *
-     * @param {mat4} out the receiving matrix
+     * @template {mat4} T
+     * @param {T} out the receiving matrix
      * @param {ReadonlyMat4} a the first operand
      * @param {ReadonlyMat4} b the second operand
-     * @returns {mat4} out
+     * @returns {Mat4Result<T>} out
      */
-    export function sub(out: mat4, a: ReadonlyMat4, b: ReadonlyMat4): mat4;
+    export function sub<T extends mat4>(out: T, a: ReadonlyMat4, b: ReadonlyMat4): Mat4Result<T>;
 }
 export namespace vec3 {
     /**
@@ -1498,16 +1653,16 @@ export namespace vec3 {
     /**
      * Creates a new, empty vec3
      *
-     * @returns {vec3} a new 3D vector
+     * @returns {vec3<DefaultArrayType>} a new 3D vector
      */
-    export function create(): vec3;
+    export function create(): vec3<DefaultArrayType>;
     /**
      * Creates a new vec3 initialized with values from an existing vector
      *
      * @param {ReadonlyVec3} a vector to clone
-     * @returns {vec3} a new 3D vector
+     * @returns {vec3<DefaultArrayType>} a new 3D vector
      */
-    export function clone(a: ReadonlyVec3): vec3;
+    export function clone(a: ReadonlyVec3): vec3<DefaultArrayType>;
     /**
      * Calculates the length of a vec3
      *
@@ -1521,124 +1676,137 @@ export namespace vec3 {
      * @param {Number} x X component
      * @param {Number} y Y component
      * @param {Number} z Z component
-     * @returns {vec3} a new 3D vector
+     * @returns {vec3<DefaultArrayType>} a new 3D vector
      */
-    export function fromValues(x: number, y: number, z: number): vec3;
+    export function fromValues(x: number, y: number, z: number): vec3<DefaultArrayType>;
     /**
      * Copy the values from one vec3 to another
      *
-     * @param {vec3} out the receiving vector
+     * @template {vec3} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyVec3} a the source vector
-     * @returns {vec3} out
+     * @returns {Vec3Result<T>} out
      */
-    export function copy(out: vec3, a: ReadonlyVec3): vec3;
+    export function copy<T extends vec3>(out: T, a: ReadonlyVec3): Vec3Result<T>;
     /**
      * Set the components of a vec3 to the given values
      *
-     * @param {vec3} out the receiving vector
+     * @template {vec3} T
+     * @param {T} out the receiving vector
      * @param {Number} x X component
      * @param {Number} y Y component
      * @param {Number} z Z component
-     * @returns {vec3} out
+     * @returns {Vec3Result<T>} out
      */
-    export function set(out: vec3, x: number, y: number, z: number): vec3;
+    export function set<T extends vec3>(out: T, x: number, y: number, z: number): Vec3Result<T>;
     /**
      * Adds two vec3's
      *
-     * @param {vec3} out the receiving vector
+     * @template {vec3} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyVec3} a the first operand
      * @param {ReadonlyVec3} b the second operand
-     * @returns {vec3} out
+     * @returns {Vec3Result<T>} out
      */
-    export function add(out: vec3, a: ReadonlyVec3, b: ReadonlyVec3): vec3;
+    export function add<T extends vec3>(out: T, a: ReadonlyVec3, b: ReadonlyVec3): Vec3Result<T>;
     /**
      * Subtracts vector b from vector a
      *
-     * @param {vec3} out the receiving vector
+     * @template {vec3} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyVec3} a the first operand
      * @param {ReadonlyVec3} b the second operand
-     * @returns {vec3} out
+     * @returns {Vec3Result<T>} out
      */
-    export function subtract(out: vec3, a: ReadonlyVec3, b: ReadonlyVec3): vec3;
+    export function subtract<T extends vec3>(out: T, a: ReadonlyVec3, b: ReadonlyVec3): Vec3Result<T>;
     /**
      * Multiplies two vec3's
      *
-     * @param {vec3} out the receiving vector
+     * @template {vec3} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyVec3} a the first operand
      * @param {ReadonlyVec3} b the second operand
-     * @returns {vec3} out
+     * @returns {Vec3Result<T>} out
      */
-    export function multiply(out: vec3, a: ReadonlyVec3, b: ReadonlyVec3): vec3;
+    export function multiply<T extends vec3>(out: T, a: ReadonlyVec3, b: ReadonlyVec3): Vec3Result<T>;
     /**
      * Divides two vec3's
      *
-     * @param {vec3} out the receiving vector
+     * @template {vec3} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyVec3} a the first operand
      * @param {ReadonlyVec3} b the second operand
-     * @returns {vec3} out
+     * @returns {Vec3Result<T>} out
      */
-    export function divide(out: vec3, a: ReadonlyVec3, b: ReadonlyVec3): vec3;
+    export function divide<T extends vec3>(out: T, a: ReadonlyVec3, b: ReadonlyVec3): Vec3Result<T>;
     /**
      * Math.ceil the components of a vec3
      *
-     * @param {vec3} out the receiving vector
+     * @template {vec3} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyVec3} a vector to ceil
-     * @returns {vec3} out
+     * @returns {Vec3Result<T>} out
      */
-    export function ceil(out: vec3, a: ReadonlyVec3): vec3;
+    export function ceil<T extends vec3>(out: T, a: ReadonlyVec3): Vec3Result<T>;
     /**
      * Math.floor the components of a vec3
      *
-     * @param {vec3} out the receiving vector
+     * @template {vec3} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyVec3} a vector to floor
-     * @returns {vec3} out
+     * @returns {Vec3Result<T>} out
      */
-    export function floor(out: vec3, a: ReadonlyVec3): vec3;
+    export function floor<T extends vec3>(out: T, a: ReadonlyVec3): Vec3Result<T>;
     /**
      * Returns the minimum of two vec3's
      *
-     * @param {vec3} out the receiving vector
+     * @template {vec3} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyVec3} a the first operand
      * @param {ReadonlyVec3} b the second operand
-     * @returns {vec3} out
+     * @returns {Vec3Result<T>} out
      */
-    export function min(out: vec3, a: ReadonlyVec3, b: ReadonlyVec3): vec3;
+    export function min<T extends vec3>(out: T, a: ReadonlyVec3, b: ReadonlyVec3): Vec3Result<T>;
     /**
      * Returns the maximum of two vec3's
      *
-     * @param {vec3} out the receiving vector
+     * @template {vec3} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyVec3} a the first operand
      * @param {ReadonlyVec3} b the second operand
-     * @returns {vec3} out
+     * @returns {Vec3Result<T>} out
      */
-    export function max(out: vec3, a: ReadonlyVec3, b: ReadonlyVec3): vec3;
+    export function max<T extends vec3>(out: T, a: ReadonlyVec3, b: ReadonlyVec3): Vec3Result<T>;
     /**
      * symmetric round the components of a vec3
      *
-     * @param {vec3} out the receiving vector
+     * @template {vec3} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyVec3} a vector to round
-     * @returns {vec3} out
+     * @returns {Vec3Result<T>} out
      */
-    export function round(out: vec3, a: ReadonlyVec3): vec3;
+    export function round<T extends vec3>(out: T, a: ReadonlyVec3): Vec3Result<T>;
     /**
      * Scales a vec3 by a scalar number
      *
-     * @param {vec3} out the receiving vector
+     * @template {vec3} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyVec3} a the vector to scale
      * @param {Number} b amount to scale the vector by
-     * @returns {vec3} out
+     * @returns {Vec3Result<T>} out
      */
-    export function scale(out: vec3, a: ReadonlyVec3, b: number): vec3;
+    export function scale<T extends vec3>(out: T, a: ReadonlyVec3, b: number): Vec3Result<T>;
     /**
      * Adds two vec3's after scaling the second operand by a scalar value
      *
-     * @param {vec3} out the receiving vector
+     * @template {vec3} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyVec3} a the first operand
      * @param {ReadonlyVec3} b the second operand
      * @param {Number} scale the amount to scale b by before adding
-     * @returns {vec3} out
+     * @returns {Vec3Result<T>} out
      */
-    export function scaleAndAdd(out: vec3, a: ReadonlyVec3, b: ReadonlyVec3, scale: number): vec3;
+    export function scaleAndAdd<T extends vec3>(out: T, a: ReadonlyVec3, b: ReadonlyVec3, scale: number): Vec3Result<T>;
     /**
      * Calculates the euclidian distance between two vec3's
      *
@@ -1665,27 +1833,30 @@ export namespace vec3 {
     /**
      * Negates the components of a vec3
      *
-     * @param {vec3} out the receiving vector
+     * @template {vec3} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyVec3} a vector to negate
-     * @returns {vec3} out
+     * @returns {Vec3Result<T>} out
      */
-    export function negate(out: vec3, a: ReadonlyVec3): vec3;
+    export function negate<T extends vec3>(out: T, a: ReadonlyVec3): Vec3Result<T>;
     /**
      * Returns the inverse of the components of a vec3
      *
-     * @param {vec3} out the receiving vector
+     * @template {vec3} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyVec3} a vector to invert
-     * @returns {vec3} out
+     * @returns {Vec3Result<T>} out
      */
-    export function inverse(out: vec3, a: ReadonlyVec3): vec3;
+    export function inverse<T extends vec3>(out: T, a: ReadonlyVec3): Vec3Result<T>;
     /**
      * Normalize a vec3
      *
-     * @param {vec3} out the receiving vector
+     * @template {vec3} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyVec3} a vector to normalize
-     * @returns {vec3} out
+     * @returns {Vec3Result<T>} out
      */
-    export function normalize(out: vec3, a: ReadonlyVec3): vec3;
+    export function normalize<T extends vec3>(out: T, a: ReadonlyVec3): Vec3Result<T>;
     /**
      * Calculates the dot product of two vec3's
      *
@@ -1697,120 +1868,132 @@ export namespace vec3 {
     /**
      * Computes the cross product of two vec3's
      *
-     * @param {vec3} out the receiving vector
+     * @template {vec3} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyVec3} a the first operand
      * @param {ReadonlyVec3} b the second operand
-     * @returns {vec3} out
+     * @returns {Vec3Result<T>} out
      */
-    export function cross(out: vec3, a: ReadonlyVec3, b: ReadonlyVec3): vec3;
+    export function cross<T extends vec3>(out: T, a: ReadonlyVec3, b: ReadonlyVec3): Vec3Result<T>;
     /**
      * Performs a linear interpolation between two vec3's
      *
-     * @param {vec3} out the receiving vector
+     * @template {vec3} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyVec3} a the first operand
      * @param {ReadonlyVec3} b the second operand
      * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
-     * @returns {vec3} out
+     * @returns {Vec3Result<T>} out
      */
-    export function lerp(out: vec3, a: ReadonlyVec3, b: ReadonlyVec3, t: number): vec3;
+    export function lerp<T extends vec3>(out: T, a: ReadonlyVec3, b: ReadonlyVec3, t: number): Vec3Result<T>;
     /**
      * Performs a spherical linear interpolation between two vec3's
      *
-     * @param {vec3} out the receiving vector
+     * @template {vec3} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyVec3} a the first operand
      * @param {ReadonlyVec3} b the second operand
      * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
-     * @returns {vec3} out
+     * @returns {Vec3Result<T>} out
      */
-    export function slerp(out: vec3, a: ReadonlyVec3, b: ReadonlyVec3, t: number): vec3;
+    export function slerp<T extends vec3>(out: T, a: ReadonlyVec3, b: ReadonlyVec3, t: number): Vec3Result<T>;
     /**
      * Performs a hermite interpolation with two control points
      *
-     * @param {vec3} out the receiving vector
+     * @template {vec3} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyVec3} a the first operand
      * @param {ReadonlyVec3} b the second operand
      * @param {ReadonlyVec3} c the third operand
      * @param {ReadonlyVec3} d the fourth operand
      * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
-     * @returns {vec3} out
+     * @returns {Vec3Result<T>} out
      */
-    export function hermite(out: vec3, a: ReadonlyVec3, b: ReadonlyVec3, c: ReadonlyVec3, d: ReadonlyVec3, t: number): vec3;
+    export function hermite<T extends vec3>(out: T, a: ReadonlyVec3, b: ReadonlyVec3, c: ReadonlyVec3, d: ReadonlyVec3, t: number): Vec3Result<T>;
     /**
      * Performs a bezier interpolation with two control points
      *
-     * @param {vec3} out the receiving vector
+     * @template {vec3} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyVec3} a the first operand
      * @param {ReadonlyVec3} b the second operand
      * @param {ReadonlyVec3} c the third operand
      * @param {ReadonlyVec3} d the fourth operand
      * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
-     * @returns {vec3} out
+     * @returns {Vec3Result<T>} out
      */
-    export function bezier(out: vec3, a: ReadonlyVec3, b: ReadonlyVec3, c: ReadonlyVec3, d: ReadonlyVec3, t: number): vec3;
+    export function bezier<T extends vec3>(out: T, a: ReadonlyVec3, b: ReadonlyVec3, c: ReadonlyVec3, d: ReadonlyVec3, t: number): Vec3Result<T>;
     /**
      * Generates a random vector with the given scale
      *
-     * @param {vec3} out the receiving vector
+     * @template {vec3} T
+     * @param {T} out the receiving vector
      * @param {Number} [scale] Length of the resulting vector. If omitted, a unit vector will be returned
-     * @returns {vec3} out
+     * @returns {Vec3Result<T>} out
      */
-    export function random(out: vec3, scale?: number): vec3;
+    export function random<T extends vec3>(out: T, scale?: number): Vec3Result<T>;
     /**
      * Transforms the vec3 with a mat4.
      * 4th vector component is implicitly '1'
      *
-     * @param {vec3} out the receiving vector
+     * @template {vec3} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyVec3} a the vector to transform
      * @param {ReadonlyMat4} m matrix to transform with
-     * @returns {vec3} out
+     * @returns {Vec3Result<T>} out
      */
-    export function transformMat4(out: vec3, a: ReadonlyVec3, m: ReadonlyMat4): vec3;
+    export function transformMat4<T extends vec3>(out: T, a: ReadonlyVec3, m: ReadonlyMat4): Vec3Result<T>;
     /**
      * Transforms the vec3 with a mat3.
      *
-     * @param {vec3} out the receiving vector
+     * @template {vec3} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyVec3} a the vector to transform
      * @param {ReadonlyMat3} m the 3x3 matrix to transform with
-     * @returns {vec3} out
+     * @returns {Vec3Result<T>} out
      */
-    export function transformMat3(out: vec3, a: ReadonlyVec3, m: ReadonlyMat3): vec3;
+    export function transformMat3<T extends vec3>(out: T, a: ReadonlyVec3, m: ReadonlyMat3): Vec3Result<T>;
     /**
      * Transforms the vec3 with a quat
      * Can also be used for dual quaternions. (Multiply it with the real part)
      *
-     * @param {vec3} out the receiving vector
+     * @template {vec3} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyVec3} a the vector to transform
      * @param {ReadonlyQuat} q normalized quaternion to transform with
-     * @returns {vec3} out
+     * @returns {Vec3Result<T>} out
      */
-    export function transformQuat(out: vec3, a: ReadonlyVec3, q: ReadonlyQuat): vec3;
+    export function transformQuat<T extends vec3>(out: T, a: ReadonlyVec3, q: ReadonlyQuat): Vec3Result<T>;
     /**
      * Rotate a 3D vector around the x-axis
-     * @param {vec3} out The receiving vec3
+     * @template {vec3} T
+     * @param {T} out The receiving vec3
      * @param {ReadonlyVec3} a The vec3 point to rotate
      * @param {ReadonlyVec3} b The origin of the rotation
      * @param {Number} rad The angle of rotation in radians
-     * @returns {vec3} out
+     * @returns {Vec3Result<T>} out
      */
-    export function rotateX(out: vec3, a: ReadonlyVec3, b: ReadonlyVec3, rad: number): vec3;
+    export function rotateX<T extends vec3>(out: T, a: ReadonlyVec3, b: ReadonlyVec3, rad: number): Vec3Result<T>;
     /**
      * Rotate a 3D vector around the y-axis
-     * @param {vec3} out The receiving vec3
+     * @template {vec3} T
+     * @param {T} out The receiving vec3
      * @param {ReadonlyVec3} a The vec3 point to rotate
      * @param {ReadonlyVec3} b The origin of the rotation
      * @param {Number} rad The angle of rotation in radians
-     * @returns {vec3} out
+     * @returns {Vec3Result<T>} out
      */
-    export function rotateY(out: vec3, a: ReadonlyVec3, b: ReadonlyVec3, rad: number): vec3;
+    export function rotateY<T extends vec3>(out: T, a: ReadonlyVec3, b: ReadonlyVec3, rad: number): Vec3Result<T>;
     /**
      * Rotate a 3D vector around the z-axis
-     * @param {vec3} out The receiving vec3
+     * @template {vec3} T
+     * @param {T} out The receiving vec3
      * @param {ReadonlyVec3} a The vec3 point to rotate
      * @param {ReadonlyVec3} b The origin of the rotation
      * @param {Number} rad The angle of rotation in radians
-     * @returns {vec3} out
+     * @returns {Vec3Result<T>} out
      */
-    export function rotateZ(out: vec3, a: ReadonlyVec3, b: ReadonlyVec3, rad: number): vec3;
+    export function rotateZ<T extends vec3>(out: T, a: ReadonlyVec3, b: ReadonlyVec3, rad: number): Vec3Result<T>;
     /**
      * Get the angle between two 3D vectors
      * @param {ReadonlyVec3} a The first operand
@@ -1821,10 +2004,11 @@ export namespace vec3 {
     /**
      * Set the components of a vec3 to zero
      *
-     * @param {vec3} out the receiving vector
-     * @returns {vec3} out
+     * @template {vec3} T
+     * @param {T} out the receiving vector
+     * @returns {Vec3Result<T>} out
      */
-    export function zero(out: vec3): vec3;
+    export function zero<T extends vec3>(out: T): Vec3Result<T>;
     /**
      * Returns a string representation of a vector
      *
@@ -1851,30 +2035,33 @@ export namespace vec3 {
     /**
      * Subtracts vector b from vector a
      *
-     * @param {vec3} out the receiving vector
+     * @template {vec3} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyVec3} a the first operand
      * @param {ReadonlyVec3} b the second operand
-     * @returns {vec3} out
+     * @returns {Vec3Result<T>} out
      */
-    export function sub(out: vec3, a: ReadonlyVec3, b: ReadonlyVec3): vec3;
+    export function sub<T extends vec3>(out: T, a: ReadonlyVec3, b: ReadonlyVec3): Vec3Result<T>;
     /**
      * Multiplies two vec3's
      *
-     * @param {vec3} out the receiving vector
+     * @template {vec3} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyVec3} a the first operand
      * @param {ReadonlyVec3} b the second operand
-     * @returns {vec3} out
+     * @returns {Vec3Result<T>} out
      */
-    export function mul(out: vec3, a: ReadonlyVec3, b: ReadonlyVec3): vec3;
+    export function mul<T extends vec3>(out: T, a: ReadonlyVec3, b: ReadonlyVec3): Vec3Result<T>;
     /**
      * Divides two vec3's
      *
-     * @param {vec3} out the receiving vector
+     * @template {vec3} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyVec3} a the first operand
      * @param {ReadonlyVec3} b the second operand
-     * @returns {vec3} out
+     * @returns {Vec3Result<T>} out
      */
-    export function div(out: vec3, a: ReadonlyVec3, b: ReadonlyVec3): vec3;
+    export function div<T extends vec3>(out: T, a: ReadonlyVec3, b: ReadonlyVec3): Vec3Result<T>;
     /**
      * Calculates the euclidian distance between two vec3's
      *
@@ -1915,16 +2102,16 @@ export namespace vec4 {
     /**
      * Creates a new, empty vec4
      *
-     * @returns {vec4} a new 4D vector
+     * @returns {vec4<DefaultArrayType>} a new 4D vector
      */
-    export function create(): vec4;
+    export function create(): vec4<DefaultArrayType>;
     /**
      * Creates a new vec4 initialized with values from an existing vector
      *
      * @param {ReadonlyVec4} a vector to clone
-     * @returns {vec4} a new 4D vector
+     * @returns {vec4<DefaultArrayType>} a new 4D vector
      */
-    export function clone(a: ReadonlyVec4): vec4;
+    export function clone(a: ReadonlyVec4): vec4<DefaultArrayType>;
     /**
      * Creates a new vec4 initialized with the given values
      *
@@ -1932,125 +2119,138 @@ export namespace vec4 {
      * @param {Number} y Y component
      * @param {Number} z Z component
      * @param {Number} w W component
-     * @returns {vec4} a new 4D vector
+     * @returns {vec4<DefaultArrayType>} a new 4D vector
      */
-    export function fromValues(x: number, y: number, z: number, w: number): vec4;
+    export function fromValues(x: number, y: number, z: number, w: number): vec4<DefaultArrayType>;
     /**
      * Copy the values from one vec4 to another
      *
-     * @param {vec4} out the receiving vector
+     * @template {vec4} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyVec4} a the source vector
-     * @returns {vec4} out
+     * @returns {Vec4Result<T>} out
      */
-    export function copy(out: vec4, a: ReadonlyVec4): vec4;
+    export function copy<T extends vec4>(out: T, a: ReadonlyVec4): Vec4Result<T>;
     /**
      * Set the components of a vec4 to the given values
      *
-     * @param {vec4} out the receiving vector
+     * @template {vec4} T
+     * @param {T} out the receiving vector
      * @param {Number} x X component
      * @param {Number} y Y component
      * @param {Number} z Z component
      * @param {Number} w W component
-     * @returns {vec4} out
+     * @returns {Vec4Result<T>} out
      */
-    export function set(out: vec4, x: number, y: number, z: number, w: number): vec4;
+    export function set<T extends vec4>(out: T, x: number, y: number, z: number, w: number): Vec4Result<T>;
     /**
      * Adds two vec4's
      *
-     * @param {vec4} out the receiving vector
+     * @template {vec4} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyVec4} a the first operand
      * @param {ReadonlyVec4} b the second operand
-     * @returns {vec4} out
+     * @returns {Vec4Result<T>} out
      */
-    export function add(out: vec4, a: ReadonlyVec4, b: ReadonlyVec4): vec4;
+    export function add<T extends vec4>(out: T, a: ReadonlyVec4, b: ReadonlyVec4): Vec4Result<T>;
     /**
      * Subtracts vector b from vector a
      *
-     * @param {vec4} out the receiving vector
+     * @template {vec4} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyVec4} a the first operand
      * @param {ReadonlyVec4} b the second operand
-     * @returns {vec4} out
+     * @returns {Vec4Result<T>} out
      */
-    export function subtract(out: vec4, a: ReadonlyVec4, b: ReadonlyVec4): vec4;
+    export function subtract<T extends vec4>(out: T, a: ReadonlyVec4, b: ReadonlyVec4): Vec4Result<T>;
     /**
      * Multiplies two vec4's
      *
-     * @param {vec4} out the receiving vector
+     * @template {vec4} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyVec4} a the first operand
      * @param {ReadonlyVec4} b the second operand
-     * @returns {vec4} out
+     * @returns {Vec4Result<T>} out
      */
-    export function multiply(out: vec4, a: ReadonlyVec4, b: ReadonlyVec4): vec4;
+    export function multiply<T extends vec4>(out: T, a: ReadonlyVec4, b: ReadonlyVec4): Vec4Result<T>;
     /**
      * Divides two vec4's
      *
-     * @param {vec4} out the receiving vector
+     * @template {vec4} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyVec4} a the first operand
      * @param {ReadonlyVec4} b the second operand
-     * @returns {vec4} out
+     * @returns {Vec4Result<T>} out
      */
-    export function divide(out: vec4, a: ReadonlyVec4, b: ReadonlyVec4): vec4;
+    export function divide<T extends vec4>(out: T, a: ReadonlyVec4, b: ReadonlyVec4): Vec4Result<T>;
     /**
      * Math.ceil the components of a vec4
      *
-     * @param {vec4} out the receiving vector
+     * @template {vec4} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyVec4} a vector to ceil
-     * @returns {vec4} out
+     * @returns {Vec4Result<T>} out
      */
-    export function ceil(out: vec4, a: ReadonlyVec4): vec4;
+    export function ceil<T extends vec4>(out: T, a: ReadonlyVec4): Vec4Result<T>;
     /**
      * Math.floor the components of a vec4
      *
-     * @param {vec4} out the receiving vector
+     * @template {vec4} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyVec4} a vector to floor
-     * @returns {vec4} out
+     * @returns {Vec4Result<T>} out
      */
-    export function floor(out: vec4, a: ReadonlyVec4): vec4;
+    export function floor<T extends vec4>(out: T, a: ReadonlyVec4): Vec4Result<T>;
     /**
      * Returns the minimum of two vec4's
      *
-     * @param {vec4} out the receiving vector
+     * @template {vec4} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyVec4} a the first operand
      * @param {ReadonlyVec4} b the second operand
-     * @returns {vec4} out
+     * @returns {Vec4Result<T>} out
      */
-    export function min(out: vec4, a: ReadonlyVec4, b: ReadonlyVec4): vec4;
+    export function min<T extends vec4>(out: T, a: ReadonlyVec4, b: ReadonlyVec4): Vec4Result<T>;
     /**
      * Returns the maximum of two vec4's
      *
-     * @param {vec4} out the receiving vector
+     * @template {vec4} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyVec4} a the first operand
      * @param {ReadonlyVec4} b the second operand
-     * @returns {vec4} out
+     * @returns {Vec4Result<T>} out
      */
-    export function max(out: vec4, a: ReadonlyVec4, b: ReadonlyVec4): vec4;
+    export function max<T extends vec4>(out: T, a: ReadonlyVec4, b: ReadonlyVec4): Vec4Result<T>;
     /**
      * symmetric round the components of a vec4
      *
-     * @param {vec4} out the receiving vector
+     * @template {vec4} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyVec4} a vector to round
-     * @returns {vec4} out
+     * @returns {Vec4Result<T>} out
      */
-    export function round(out: vec4, a: ReadonlyVec4): vec4;
+    export function round<T extends vec4>(out: T, a: ReadonlyVec4): Vec4Result<T>;
     /**
      * Scales a vec4 by a scalar number
      *
-     * @param {vec4} out the receiving vector
+     * @template {vec4} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyVec4} a the vector to scale
      * @param {Number} b amount to scale the vector by
-     * @returns {vec4} out
+     * @returns {Vec4Result<T>} out
      */
-    export function scale(out: vec4, a: ReadonlyVec4, b: number): vec4;
+    export function scale<T extends vec4>(out: T, a: ReadonlyVec4, b: number): Vec4Result<T>;
     /**
      * Adds two vec4's after scaling the second operand by a scalar value
      *
-     * @param {vec4} out the receiving vector
+     * @template {vec4} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyVec4} a the first operand
      * @param {ReadonlyVec4} b the second operand
      * @param {Number} scale the amount to scale b by before adding
-     * @returns {vec4} out
+     * @returns {Vec4Result<T>} out
      */
-    export function scaleAndAdd(out: vec4, a: ReadonlyVec4, b: ReadonlyVec4, scale: number): vec4;
+    export function scaleAndAdd<T extends vec4>(out: T, a: ReadonlyVec4, b: ReadonlyVec4, scale: number): Vec4Result<T>;
     /**
      * Calculates the euclidian distance between two vec4's
      *
@@ -2084,27 +2284,30 @@ export namespace vec4 {
     /**
      * Negates the components of a vec4
      *
-     * @param {vec4} out the receiving vector
+     * @template {vec4} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyVec4} a vector to negate
-     * @returns {vec4} out
+     * @returns {Vec4Result<T>} out
      */
-    export function negate(out: vec4, a: ReadonlyVec4): vec4;
+    export function negate<T extends vec4>(out: T, a: ReadonlyVec4): Vec4Result<T>;
     /**
      * Returns the inverse of the components of a vec4
      *
-     * @param {vec4} out the receiving vector
+     * @template {vec4} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyVec4} a vector to invert
-     * @returns {vec4} out
+     * @returns {Vec4Result<T>} out
      */
-    export function inverse(out: vec4, a: ReadonlyVec4): vec4;
+    export function inverse<T extends vec4>(out: T, a: ReadonlyVec4): Vec4Result<T>;
     /**
      * Normalize a vec4
      *
-     * @param {vec4} out the receiving vector
+     * @template {vec4} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyVec4} a vector to normalize
-     * @returns {vec4} out
+     * @returns {Vec4Result<T>} out
      */
-    export function normalize(out: vec4, a: ReadonlyVec4): vec4;
+    export function normalize<T extends vec4>(out: T, a: ReadonlyVec4): Vec4Result<T>;
     /**
      * Calculates the dot product of two vec4's
      *
@@ -2116,56 +2319,62 @@ export namespace vec4 {
     /**
      * Returns the cross-product of three vectors in a 4-dimensional space
      *
-     * @param {ReadonlyVec4} out the receiving vector
+     * @template {vec4} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyVec4} u the first vector
      * @param {ReadonlyVec4} v the second vector
      * @param {ReadonlyVec4} w the third vector
-     * @returns {vec4} result
+     * @returns {Vec4Result<T>} result
      */
-    export function cross(out: ReadonlyVec4, u: ReadonlyVec4, v: ReadonlyVec4, w: ReadonlyVec4): vec4;
+    export function cross<T extends vec4>(out: T, u: ReadonlyVec4, v: ReadonlyVec4, w: ReadonlyVec4): Vec4Result<T>;
     /**
      * Performs a linear interpolation between two vec4's
      *
-     * @param {vec4} out the receiving vector
+     * @template {vec4} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyVec4} a the first operand
      * @param {ReadonlyVec4} b the second operand
      * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
-     * @returns {vec4} out
+     * @returns {Vec4Result<T>} out
      */
-    export function lerp(out: vec4, a: ReadonlyVec4, b: ReadonlyVec4, t: number): vec4;
+    export function lerp<T extends vec4>(out: T, a: ReadonlyVec4, b: ReadonlyVec4, t: number): Vec4Result<T>;
     /**
      * Generates a random vector with the given scale
      *
-     * @param {vec4} out the receiving vector
+     * @template {vec4} T
+     * @param {T} out the receiving vector
      * @param {Number} [scale] Length of the resulting vector. If omitted, a unit vector will be returned
-     * @returns {vec4} out
+     * @returns {Vec4Result<T>} out
      */
-    export function random(out: vec4, scale?: number): vec4;
+    export function random<T extends vec4>(out: T, scale?: number): Vec4Result<T>;
     /**
      * Transforms the vec4 with a mat4.
      *
-     * @param {vec4} out the receiving vector
+     * @template {vec4} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyVec4} a the vector to transform
      * @param {ReadonlyMat4} m matrix to transform with
-     * @returns {vec4} out
+     * @returns {Vec4Result<T>} out
      */
-    export function transformMat4(out: vec4, a: ReadonlyVec4, m: ReadonlyMat4): vec4;
+    export function transformMat4<T extends vec4>(out: T, a: ReadonlyVec4, m: ReadonlyMat4): Vec4Result<T>;
     /**
      * Transforms the vec4 with a quat
      *
-     * @param {vec4} out the receiving vector
+     * @template {vec4} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyVec4} a the vector to transform
      * @param {ReadonlyQuat} q normalized quaternion to transform with
-     * @returns {vec4} out
+     * @returns {Vec4Result<T>} out
      */
-    export function transformQuat(out: vec4, a: ReadonlyVec4, q: ReadonlyQuat): vec4;
+    export function transformQuat<T extends vec4>(out: T, a: ReadonlyVec4, q: ReadonlyQuat): Vec4Result<T>;
     /**
      * Set the components of a vec4 to zero
      *
-     * @param {vec4} out the receiving vector
-     * @returns {vec4} out
+     * @template {vec4} T
+     * @param {T} out the receiving vector
+     * @returns {Vec4Result<T>} out
      */
-    export function zero(out: vec4): vec4;
+    export function zero<T extends vec4>(out: T): Vec4Result<T>;
     /**
      * Returns a string representation of a vector
      *
@@ -2192,30 +2401,33 @@ export namespace vec4 {
     /**
      * Subtracts vector b from vector a
      *
-     * @param {vec4} out the receiving vector
+     * @template {vec4} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyVec4} a the first operand
      * @param {ReadonlyVec4} b the second operand
-     * @returns {vec4} out
+     * @returns {Vec4Result<T>} out
      */
-    export function sub(out: vec4, a: ReadonlyVec4, b: ReadonlyVec4): vec4;
+    export function sub<T extends vec4>(out: T, a: ReadonlyVec4, b: ReadonlyVec4): Vec4Result<T>;
     /**
      * Multiplies two vec4's
      *
-     * @param {vec4} out the receiving vector
+     * @template {vec4} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyVec4} a the first operand
      * @param {ReadonlyVec4} b the second operand
-     * @returns {vec4} out
+     * @returns {Vec4Result<T>} out
      */
-    export function mul(out: vec4, a: ReadonlyVec4, b: ReadonlyVec4): vec4;
+    export function mul<T extends vec4>(out: T, a: ReadonlyVec4, b: ReadonlyVec4): Vec4Result<T>;
     /**
      * Divides two vec4's
      *
-     * @param {vec4} out the receiving vector
+     * @template {vec4} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyVec4} a the first operand
      * @param {ReadonlyVec4} b the second operand
-     * @returns {vec4} out
+     * @returns {Vec4Result<T>} out
      */
-    export function div(out: vec4, a: ReadonlyVec4, b: ReadonlyVec4): vec4;
+    export function div<T extends vec4>(out: T, a: ReadonlyVec4, b: ReadonlyVec4): Vec4Result<T>;
     /**
      * Calculates the euclidian distance between two vec4's
      *
@@ -2256,26 +2468,28 @@ export namespace quat {
     /**
      * Creates a new identity quat
      *
-     * @returns {quat} a new quaternion
+     * @returns {QuatResult<DefaultArrayType>} a new quaternion
      */
-    export function create(): quat;
+    export function create(): QuatResult<DefaultArrayType>;
     /**
      * Set a quat to the identity quaternion
      *
-     * @param {quat} out the receiving quaternion
-     * @returns {quat} out
+     * @template {quat} T
+     * @param {T} out the receiving quaternion
+     * @returns {QuatResult<T>} out
      */
-    export function identity(out: quat): quat;
+    export function identity<T_1 extends quat>(out: T_1): QuatResult<T_1>;
     /**
      * Sets a quat from the given angle and rotation axis,
      * then returns it.
      *
-     * @param {quat} out the receiving quaternion
+     * @template {quat} T
+     * @param {T} out the receiving quaternion
      * @param {ReadonlyVec3} axis the axis around which to rotate
      * @param {Number} rad the angle in radians
-     * @returns {quat} out
+     * @returns {QuatResult<T>} out
      **/
-    export function setAxisAngle(out: quat, axis: ReadonlyVec3, rad: number): quat;
+    export function setAxisAngle<T_1 extends quat>(out: T_1, axis: ReadonlyVec3, rad: number): QuatResult<T_1>;
     /**
      * Gets the rotation axis and angle for a given
      *  quaternion. If a quaternion is created with
@@ -2301,132 +2515,146 @@ export namespace quat {
     /**
      * Multiplies two quat's
      *
-     * @param {quat} out the receiving quaternion
+     * @template {quat} T
+     * @param {T} out the receiving quaternion
      * @param {ReadonlyQuat} a the first operand
      * @param {ReadonlyQuat} b the second operand
-     * @returns {quat} out
+     * @returns {QuatResult<T>} out
      */
-    export function multiply(out: quat, a: ReadonlyQuat, b: ReadonlyQuat): quat;
+    export function multiply<T_1 extends quat>(out: T_1, a: ReadonlyQuat, b: ReadonlyQuat): QuatResult<T_1>;
     /**
      * Rotates a quaternion by the given angle about the X axis
      *
-     * @param {quat} out quat receiving operation result
+     * @template {quat} T
+     * @param {T} out quat receiving operation result
      * @param {ReadonlyQuat} a quat to rotate
      * @param {number} rad angle (in radians) to rotate
-     * @returns {quat} out
+     * @returns {QuatResult<T>} out
      */
-    export function rotateX(out: quat, a: ReadonlyQuat, rad: number): quat;
+    export function rotateX<T_1 extends quat>(out: T_1, a: ReadonlyQuat, rad: number): QuatResult<T_1>;
     /**
      * Rotates a quaternion by the given angle about the Y axis
      *
-     * @param {quat} out quat receiving operation result
+     * @template {quat} T
+     * @param {T} out quat receiving operation result
      * @param {ReadonlyQuat} a quat to rotate
      * @param {number} rad angle (in radians) to rotate
-     * @returns {quat} out
+     * @returns {QuatResult<T>} out
      */
-    export function rotateY(out: quat, a: ReadonlyQuat, rad: number): quat;
+    export function rotateY<T_1 extends quat>(out: T_1, a: ReadonlyQuat, rad: number): QuatResult<T_1>;
     /**
      * Rotates a quaternion by the given angle about the Z axis
      *
-     * @param {quat} out quat receiving operation result
+     * @template {quat} T
+     * @param {T} out quat receiving operation result
      * @param {ReadonlyQuat} a quat to rotate
      * @param {number} rad angle (in radians) to rotate
-     * @returns {quat} out
+     * @returns {QuatResult<T>} out
      */
-    export function rotateZ(out: quat, a: ReadonlyQuat, rad: number): quat;
+    export function rotateZ<T_1 extends quat>(out: T_1, a: ReadonlyQuat, rad: number): QuatResult<T_1>;
     /**
      * Calculates the W component of a quat from the X, Y, and Z components.
      * Assumes that quaternion is 1 unit in length.
      * Any existing W component will be ignored.
      *
-     * @param {quat} out the receiving quaternion
+     * @template {quat} T
+     * @param {T} out the receiving quaternion
      * @param {ReadonlyQuat} a quat to calculate W component of
-     * @returns {quat} out
+     * @returns {QuatResult<T>} out
      */
-    export function calculateW(out: quat, a: ReadonlyQuat): quat;
+    export function calculateW<T_1 extends quat>(out: T_1, a: ReadonlyQuat): QuatResult<T_1>;
     /**
      * Calculate the exponential of a unit quaternion.
      *
-     * @param {quat} out the receiving quaternion
+     * @template {quat} T
+     * @param {T} out the receiving quaternion
      * @param {ReadonlyQuat} a quat to calculate the exponential of
-     * @returns {quat} out
+     * @returns {QuatResult<T>} out
      */
-    export function exp(out: quat, a: ReadonlyQuat): quat;
+    export function exp<T_1 extends quat>(out: T_1, a: ReadonlyQuat): QuatResult<T_1>;
     /**
      * Calculate the natural logarithm of a unit quaternion.
      *
-     * @param {quat} out the receiving quaternion
+     * @template {quat} T
+     * @param {T} out the receiving quaternion
      * @param {ReadonlyQuat} a quat to calculate the exponential of
-     * @returns {quat} out
+     * @returns {QuatResult<T>} out
      */
-    export function ln(out: quat, a: ReadonlyQuat): quat;
+    export function ln<T_1 extends quat>(out: T_1, a: ReadonlyQuat): QuatResult<T_1>;
     /**
      * Calculate the scalar power of a unit quaternion.
      *
-     * @param {quat} out the receiving quaternion
+     * @template {quat} T
+     * @param {T} out the receiving quaternion
      * @param {ReadonlyQuat} a quat to calculate the exponential of
      * @param {Number} b amount to scale the quaternion by
-     * @returns {quat} out
+     * @returns {QuatResult<T>} out
      */
-    export function pow(out: quat, a: ReadonlyQuat, b: number): quat;
+    export function pow<T_1 extends quat>(out: T_1, a: ReadonlyQuat, b: number): QuatResult<T_1>;
     /**
      * Performs a spherical linear interpolation between two quat
      *
-     * @param {quat} out the receiving quaternion
+     * @template {quat} T
+     * @param {T} out the receiving quaternion
      * @param {ReadonlyQuat} a the first operand
      * @param {ReadonlyQuat} b the second operand
      * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
-     * @returns {quat} out
+     * @returns {QuatResult<T>} out
      */
-    export function slerp(out: quat, a: ReadonlyQuat, b: ReadonlyQuat, t: number): quat;
+    export function slerp<T_1 extends quat>(out: T_1, a: ReadonlyQuat, b: ReadonlyQuat, t: number): QuatResult<T_1>;
     /**
      * Generates a random unit quaternion
      *
-     * @param {quat} out the receiving quaternion
-     * @returns {quat} out
+     * @template {quat} T
+     * @param {T} out the receiving quaternion
+     * @returns {QuatResult<T>} out
      */
-    export function random(out: quat): quat;
+    export function random<T_1 extends quat>(out: T_1): QuatResult<T_1>;
     /**
      * Calculates the inverse of a quat
      *
-     * @param {quat} out the receiving quaternion
+     * @template {quat} T
+     * @param {T} out the receiving quaternion
      * @param {ReadonlyQuat} a quat to calculate inverse of
-     * @returns {quat} out
+     * @returns {QuatResult<T>} out
      */
-    export function invert(out: quat, a: ReadonlyQuat): quat;
+    export function invert<T_1 extends quat>(out: T_1, a: ReadonlyQuat): QuatResult<T_1>;
     /**
      * Calculates the conjugate of a quat
      * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
      *
-     * @param {quat} out the receiving quaternion
+     * @template {quat} T
+     * @param {T} out the receiving quaternion
      * @param {ReadonlyQuat} a quat to calculate conjugate of
-     * @returns {quat} out
+     * @returns {QuatResult<T>} out
      */
-    export function conjugate(out: quat, a: ReadonlyQuat): quat;
+    export function conjugate<T_1 extends quat>(out: T_1, a: ReadonlyQuat): QuatResult<T_1>;
     /**
      * Creates a quaternion from the given 3x3 rotation matrix.
      *
      * NOTE: The resultant quaternion is not normalized, so you should be sure
      * to renormalize the quaternion yourself where necessary.
      *
-     * @param {quat} out the receiving quaternion
+     * @template {quat} T
+     * @param {T} out the receiving quaternion
      * @param {ReadonlyMat3} m rotation matrix
-     * @returns {quat} out
+     * @returns {QuatResult<T>} out
      * @function
      */
-    export function fromMat3(out: quat, m: ReadonlyMat3): quat;
+    export function fromMat3<T_1 extends quat>(out: T_1, m: ReadonlyMat3): QuatResult<T_1>;
     /**
      * Creates a quaternion from the given euler angle x, y, z using the provided intrinsic order for the conversion.
      *
-     * @param {quat} out the receiving quaternion
+     * @template {quat} T
+     * @param {T} out the receiving quaternion
      * @param {Number} x Angle to rotate around X axis in degrees.
      * @param {Number} y Angle to rotate around Y axis in degrees.
      * @param {Number} z Angle to rotate around Z axis in degrees.
      * @param {'xyz'|'xzy'|'yxz'|'yzx'|'zxy'|'zyx'} order Intrinsic order for conversion, default is zyx.
-     * @returns {quat} out
+     * @returns {QuatResult<T>} out
      * @function
      */
-    export function fromEuler(out: quat, x: number, y: number, z: number, order?: "xyz" | "xzy" | "yxz" | "yzx" | "zxy" | "zyx"): quat;
+    export function fromEuler<T_1 extends quat>(out: T_1, x: number, y: number, z: number, order?: "xyz" | "xzy" | "yxz" | "yzx" | "zxy" | "zyx"): QuatResult<T_1>;
     /**
      * Returns a string representation of a quaternion
      *
@@ -2448,7 +2676,7 @@ export namespace quat {
      * Creates a new quat initialized with values from an existing quaternion
      *
      * @param {ReadonlyQuat} a quaternion to clone
-     * @returns {quat} a new quaternion
+     * @returns {QuatResult<DefaultArrayType>} a new quaternion
      * @function
      */
     export const clone: typeof vec4.clone;
@@ -2459,57 +2687,62 @@ export namespace quat {
      * @param {Number} y Y component
      * @param {Number} z Z component
      * @param {Number} w W component
-     * @returns {quat} a new quaternion
+     * @returns {QuatResult<DefaultArrayType>} a new quaternion
      * @function
      */
     export const fromValues: typeof vec4.fromValues;
     /**
      * Copy the values from one quat to another
      *
-     * @param {quat} out the receiving quaternion
+     * @template {quat} T
+     * @param {T} out the receiving quaternion
      * @param {ReadonlyQuat} a the source quaternion
-     * @returns {quat} out
+     * @returns {QuatResult<T>} out
      * @function
      */
     export const copy: typeof vec4.copy;
     /**
      * Set the components of a quat to the given values
      *
-     * @param {quat} out the receiving quaternion
+     * @template {quat} T
+     * @param {T} out the receiving quaternion
      * @param {Number} x X component
      * @param {Number} y Y component
      * @param {Number} z Z component
      * @param {Number} w W component
-     * @returns {quat} out
+     * @returns {QuatResult<T>} out
      * @function
      */
     export const set: typeof vec4.set;
     /**
      * Adds two quat's
      *
-     * @param {quat} out the receiving quaternion
+     * @template {quat} T
+     * @param {T} out the receiving quaternion
      * @param {ReadonlyQuat} a the first operand
      * @param {ReadonlyQuat} b the second operand
-     * @returns {quat} out
+     * @returns {QuatResult<T>} out
      * @function
      */
     export const add: typeof vec4.add;
     /**
      * Multiplies two quat's
      *
-     * @param {quat} out the receiving quaternion
+     * @template {quat} T
+     * @param {T} out the receiving quaternion
      * @param {ReadonlyQuat} a the first operand
      * @param {ReadonlyQuat} b the second operand
-     * @returns {quat} out
+     * @returns {QuatResult<T>} out
      */
-    export function mul(out: quat, a: ReadonlyQuat, b: ReadonlyQuat): quat;
+    export function mul<T_1 extends quat>(out: T_1, a: ReadonlyQuat, b: ReadonlyQuat): QuatResult<T_1>;
     /**
      * Scales a quat by a scalar number
      *
-     * @param {quat} out the receiving vector
+     * @template {quat} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyQuat} a the vector to scale
      * @param {Number} b amount to scale the vector by
-     * @returns {quat} out
+     * @returns {QuatResult<T>} out
      * @function
      */
     export const scale: typeof vec4.scale;
@@ -2525,11 +2758,12 @@ export namespace quat {
     /**
      * Performs a linear interpolation between two quat's
      *
-     * @param {quat} out the receiving quaternion
+     * @template {quat} T
+     * @param {T} out the receiving quaternion
      * @param {ReadonlyQuat} a the first operand
      * @param {ReadonlyQuat} b the second operand
      * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
-     * @returns {quat} out
+     * @returns {QuatResult<T>} out
      * @function
      */
     export const lerp: typeof vec4.lerp;
@@ -2561,9 +2795,10 @@ export namespace quat {
     /**
      * Normalize a quat
      *
-     * @param {quat} out the receiving quaternion
+     * @template {quat} T
+     * @param {T} out the receiving quaternion
      * @param {ReadonlyQuat} a quaternion to normalize
-     * @returns {quat} out
+     * @returns {QuatResult<T>} out
      * @function
      */
     export const normalize: typeof vec4.normalize;
@@ -2577,7 +2812,7 @@ export namespace quat {
     export const exactEquals: typeof vec4.exactEquals;
     export function rotationTo(out: any, a: any, b: any): any;
     export function sqlerp(out: any, a: any, b: any, c: any, d: any, t: any): any;
-    export function setAxes(out: any, view: any, right: any, up: any): vec4;
+    export function setAxes(out: any, view: any, right: any, up: any): Vec4Tuple | TypedArrayTuple<any, 4>;
 
 }
 export namespace quat2 {
@@ -2591,17 +2826,17 @@ export namespace quat2 {
     /**
      * Creates a new identity dual quat
      *
-     * @returns {quat2} a new dual quaternion [real -> rotation, dual -> translation]
+     * @returns {quat2<DefaultArrayType>} a new dual quaternion [real -> rotation, dual -> translation]
      */
-    export function create(): quat2;
+    export function create(): quat2<DefaultArrayType>;
     /**
      * Creates a new quat initialized with values from an existing quaternion
      *
      * @param {ReadonlyQuat2} a dual quaternion to clone
-     * @returns {quat2} new dual quaternion
+     * @returns {quat2<DefaultArrayType>} new dual quaternion
      * @function
      */
-    export function clone(a: ReadonlyQuat2): quat2;
+    export function clone(a: ReadonlyQuat2): quat2<DefaultArrayType>;
     /**
      * Creates a new dual quat initialized with the given values
      *
@@ -2613,10 +2848,10 @@ export namespace quat2 {
      * @param {Number} y2 Y component
      * @param {Number} z2 Z component
      * @param {Number} w2 W component
-     * @returns {quat2} new dual quaternion
+     * @returns {quat2<DefaultArrayType>} new dual quaternion
      * @function
      */
-    export function fromValues(x1: number, y1: number, z1: number, w1: number, x2: number, y2: number, z2: number, w2: number): quat2;
+    export function fromValues(x1: number, y1: number, z1: number, w1: number, x2: number, y2: number, z2: number, w2: number): quat2<DefaultArrayType>;
     /**
      * Creates a new dual quat from the given values (quat and translation)
      *
@@ -2627,67 +2862,74 @@ export namespace quat2 {
      * @param {Number} x2 X component (translation)
      * @param {Number} y2 Y component (translation)
      * @param {Number} z2 Z component (translation)
-     * @returns {quat2} new dual quaternion
+     * @returns {quat2<DefaultArrayType>} new dual quaternion
      * @function
      */
-    export function fromRotationTranslationValues(x1: number, y1: number, z1: number, w1: number, x2: number, y2: number, z2: number): quat2;
+    export function fromRotationTranslationValues(x1: number, y1: number, z1: number, w1: number, x2: number, y2: number, z2: number): quat2<DefaultArrayType>;
     /**
      * Creates a dual quat from a quaternion and a translation
      *
-     * @param {ReadonlyQuat2} dual quaternion receiving operation result
+     * @template {quat2} T
+     * @param {T} out dual quaternion receiving operation result
      * @param {ReadonlyQuat} q a normalized quaternion
      * @param {ReadonlyVec3} t translation vector
-     * @returns {quat2} dual quaternion receiving operation result
+     * @returns {Quat2Result<T>} dual quaternion receiving operation result
      * @function
      */
-    export function fromRotationTranslation(out: any, q: ReadonlyQuat, t: ReadonlyVec3): quat2;
+    export function fromRotationTranslation<T_1 extends quat2>(out: T_1, q: ReadonlyQuat, t: ReadonlyVec3): Quat2Result<T_1>;
     /**
      * Creates a dual quat from a translation
      *
-     * @param {ReadonlyQuat2} dual quaternion receiving operation result
+     * @template {quat2} T
+     * @param {T} out dual quaternion receiving operation result
      * @param {ReadonlyVec3} t translation vector
-     * @returns {quat2} dual quaternion receiving operation result
+     * @returns {Quat2Result<T>} dual quaternion receiving operation result
      * @function
      */
-    export function fromTranslation(out: any, t: ReadonlyVec3): quat2;
+    export function fromTranslation<T_1 extends quat2>(out: T_1, t: ReadonlyVec3): Quat2Result<T_1>;
     /**
      * Creates a dual quat from a quaternion
      *
-     * @param {ReadonlyQuat2} dual quaternion receiving operation result
+     * @template {quat2} T
+     * @param {T} out dual quaternion receiving operation result
      * @param {ReadonlyQuat} q the quaternion
-     * @returns {quat2} dual quaternion receiving operation result
+     * @returns {Quat2Result<T>} dual quaternion receiving operation result
      * @function
      */
-    export function fromRotation(out: any, q: ReadonlyQuat): quat2;
+    export function fromRotation<T_1 extends quat2>(out: T_1, q: ReadonlyQuat): Quat2Result<T_1>;
     /**
      * Creates a new dual quat from a matrix (4x4)
      *
-     * @param {quat2} out the dual quaternion
+     * @template {quat2} T
+     * @param {T} out the dual quaternion
      * @param {ReadonlyMat4} a the matrix
-     * @returns {quat2} dual quat receiving operation result
+     * @returns {Quat2Result<T>} dual quat receiving operation result
      * @function
      */
-    export function fromMat4(out: quat2, a: ReadonlyMat4): quat2;
+    export function fromMat4<T_1 extends quat2>(out: T_1, a: ReadonlyMat4): Quat2Result<T_1>;
     /**
      * Copy the values from one dual quat to another
      *
-     * @param {quat2} out the receiving dual quaternion
+     * @template {quat2} T
+     * @param {T} out the receiving dual quaternion
      * @param {ReadonlyQuat2} a the source dual quaternion
-     * @returns {quat2} out
+     * @returns {Quat2Result<T>} out
      * @function
      */
-    export function copy(out: quat2, a: ReadonlyQuat2): quat2;
+    export function copy<T_1 extends quat2>(out: T_1, a: ReadonlyQuat2): Quat2Result<T_1>;
     /**
      * Set a dual quat to the identity dual quaternion
      *
-     * @param {quat2} out the receiving quaternion
-     * @returns {quat2} out
+     * @template {quat2} T
+     * @param {T} out the receiving quaternion
+     * @returns {Quat2Result<T>} out
      */
-    export function identity(out: quat2): quat2;
+    export function identity<T_1 extends quat2>(out: T_1): Quat2Result<T_1>;
     /**
      * Set the components of a dual quat to the given values
      *
-     * @param {quat2} out the receiving quaternion
+     * @template {quat2} T
+     * @param {T} out the receiving quaternion
      * @param {Number} x1 X component
      * @param {Number} y1 Y component
      * @param {Number} z1 Z component
@@ -2696,10 +2938,10 @@ export namespace quat2 {
      * @param {Number} y2 Y component
      * @param {Number} z2 Z component
      * @param {Number} w2 W component
-     * @returns {quat2} out
+     * @returns {Quat2Result<T>} out
      * @function
      */
-    export function set(out: quat2, x1: number, y1: number, z1: number, w1: number, x2: number, y2: number, z2: number, w2: number): quat2;
+    export function set<T_1 extends quat2>(out: T_1, x1: number, y1: number, z1: number, w1: number, x2: number, y2: number, z2: number, w2: number): Quat2Result<T_1>;
     /**
      * Gets the dual part of a dual quat
      * @param  {quat} out dual part
@@ -2710,12 +2952,13 @@ export namespace quat2 {
     /**
      * Set the dual component of a dual quat to the given quaternion
      *
-     * @param {quat2} out the receiving quaternion
+     * @template {quat2} T
+     * @param {T} out the receiving quaternion
      * @param {ReadonlyQuat} q a quaternion representing the dual part
-     * @returns {quat2} out
+     * @returns {Quat2Result<T>} out
      * @function
      */
-    export function setDual(out: quat2, q: ReadonlyQuat): quat2;
+    export function setDual<T_1 extends quat2>(out: T_1, q: ReadonlyQuat): Quat2Result<T_1>;
     /**
      * Gets the translation of a normalized dual quat
      * @param  {vec3} out translation
@@ -2726,133 +2969,147 @@ export namespace quat2 {
     /**
      * Translates a dual quat by the given vector
      *
-     * @param {quat2} out the receiving dual quaternion
+     * @template {quat2} T
+     * @param {T} out the receiving dual quaternion
      * @param {ReadonlyQuat2} a the dual quaternion to translate
      * @param {ReadonlyVec3} v vector to translate by
-     * @returns {quat2} out
+     * @returns {Quat2Result<T>} out
      */
-    export function translate(out: quat2, a: ReadonlyQuat2, v: ReadonlyVec3): quat2;
+    export function translate<T_1 extends quat2>(out: T_1, a: ReadonlyQuat2, v: ReadonlyVec3): Quat2Result<T_1>;
     /**
      * Rotates a dual quat around the X axis
      *
-     * @param {quat2} out the receiving dual quaternion
+     * @template {quat2} T
+     * @param {T} out the receiving dual quaternion
      * @param {ReadonlyQuat2} a the dual quaternion to rotate
      * @param {number} rad how far should the rotation be
-     * @returns {quat2} out
+     * @returns {Quat2Result<T>} out
      */
-    export function rotateX(out: quat2, a: ReadonlyQuat2, rad: number): quat2;
+    export function rotateX<T_1 extends quat2>(out: T_1, a: ReadonlyQuat2, rad: number): Quat2Result<T_1>;
     /**
      * Rotates a dual quat around the Y axis
      *
-     * @param {quat2} out the receiving dual quaternion
+     * @template {quat2} T
+     * @param {T} out the receiving dual quaternion
      * @param {ReadonlyQuat2} a the dual quaternion to rotate
      * @param {number} rad how far should the rotation be
-     * @returns {quat2} out
+     * @returns {Quat2Result<T>} out
      */
-    export function rotateY(out: quat2, a: ReadonlyQuat2, rad: number): quat2;
+    export function rotateY<T_1 extends quat2>(out: T_1, a: ReadonlyQuat2, rad: number): Quat2Result<T_1>;
     /**
      * Rotates a dual quat around the Z axis
      *
-     * @param {quat2} out the receiving dual quaternion
+     * @template {quat2} T
+     * @param {T} out the receiving dual quaternion
      * @param {ReadonlyQuat2} a the dual quaternion to rotate
      * @param {number} rad how far should the rotation be
-     * @returns {quat2} out
+     * @returns {Quat2Result<T>} out
      */
-    export function rotateZ(out: quat2, a: ReadonlyQuat2, rad: number): quat2;
+    export function rotateZ<T_1 extends quat2>(out: T_1, a: ReadonlyQuat2, rad: number): Quat2Result<T_1>;
     /**
      * Rotates a dual quat by a given quaternion (a * q)
      *
-     * @param {quat2} out the receiving dual quaternion
+     * @template {quat2} T
+     * @param {T} out the receiving dual quaternion
      * @param {ReadonlyQuat2} a the dual quaternion to rotate
      * @param {ReadonlyQuat} q quaternion to rotate by
-     * @returns {quat2} out
+     * @returns {Quat2Result<T>} out
      */
-    export function rotateByQuatAppend(out: quat2, a: ReadonlyQuat2, q: ReadonlyQuat): quat2;
+    export function rotateByQuatAppend<T_1 extends quat2>(out: T_1, a: ReadonlyQuat2, q: ReadonlyQuat): Quat2Result<T_1>;
     /**
      * Rotates a dual quat by a given quaternion (q * a)
      *
-     * @param {quat2} out the receiving dual quaternion
+     * @template {quat2} T
+     * @param {T} out the receiving dual quaternion
      * @param {ReadonlyQuat} q quaternion to rotate by
      * @param {ReadonlyQuat2} a the dual quaternion to rotate
-     * @returns {quat2} out
+     * @returns {Quat2Result<T>} out
      */
-    export function rotateByQuatPrepend(out: quat2, q: ReadonlyQuat, a: ReadonlyQuat2): quat2;
+    export function rotateByQuatPrepend<T_1 extends quat2>(out: T_1, q: ReadonlyQuat, a: ReadonlyQuat2): Quat2Result<T_1>;
     /**
      * Rotates a dual quat around a given axis. Does the normalisation automatically
      *
-     * @param {quat2} out the receiving dual quaternion
+     * @template {quat2} T
+     * @param {T} out the receiving dual quaternion
      * @param {ReadonlyQuat2} a the dual quaternion to rotate
      * @param {ReadonlyVec3} axis the axis to rotate around
      * @param {Number} rad how far the rotation should be
-     * @returns {quat2} out
+     * @returns {Quat2Result<T>} out
      */
-    export function rotateAroundAxis(out: quat2, a: ReadonlyQuat2, axis: ReadonlyVec3, rad: number): quat2;
+    export function rotateAroundAxis<T_1 extends quat2>(out: T_1, a: ReadonlyQuat2, axis: ReadonlyVec3, rad: number): Quat2Result<T_1>;
     /**
      * Adds two dual quat's
      *
-     * @param {quat2} out the receiving dual quaternion
+     * @template {quat2} T
+     * @param {T} out the receiving dual quaternion
      * @param {ReadonlyQuat2} a the first operand
      * @param {ReadonlyQuat2} b the second operand
-     * @returns {quat2} out
+     * @returns {Quat2Result<T>} out
      * @function
      */
-    export function add(out: quat2, a: ReadonlyQuat2, b: ReadonlyQuat2): quat2;
+    export function add<T_1 extends quat2>(out: T_1, a: ReadonlyQuat2, b: ReadonlyQuat2): Quat2Result<T_1>;
     /**
      * Multiplies two dual quat's
      *
-     * @param {quat2} out the receiving dual quaternion
+     * @template {quat2} T
+     * @param {T} out the receiving dual quaternion
      * @param {ReadonlyQuat2} a the first operand
      * @param {ReadonlyQuat2} b the second operand
-     * @returns {quat2} out
+     * @returns {Quat2Result<T>} out
      */
-    export function multiply(out: quat2, a: ReadonlyQuat2, b: ReadonlyQuat2): quat2;
+    export function multiply<T_1 extends quat2>(out: T_1, a: ReadonlyQuat2, b: ReadonlyQuat2): Quat2Result<T_1>;
     /**
      * Scales a dual quat by a scalar number
      *
-     * @param {quat2} out the receiving dual quat
+     * @template {quat2} T
+     * @param {T} out the receiving dual quat
      * @param {ReadonlyQuat2} a the dual quat to scale
      * @param {Number} b amount to scale the dual quat by
-     * @returns {quat2} out
+     * @returns {Quat2Result<T>} out
      * @function
      */
-    export function scale(out: quat2, a: ReadonlyQuat2, b: number): quat2;
+    export function scale<T_1 extends quat2>(out: T_1, a: ReadonlyQuat2, b: number): Quat2Result<T_1>;
     /**
      * Performs a linear interpolation between two dual quats's
      * NOTE: The resulting dual quaternions won't always be normalized (The error is most noticeable when t = 0.5)
      *
-     * @param {quat2} out the receiving dual quat
+     * @template {quat2} T
+     * @param {T} out the receiving dual quat
      * @param {ReadonlyQuat2} a the first operand
      * @param {ReadonlyQuat2} b the second operand
      * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
-     * @returns {quat2} out
+     * @returns {Quat2Result<T>} out
      */
-    export function lerp(out: quat2, a: ReadonlyQuat2, b: ReadonlyQuat2, t: number): quat2;
+    export function lerp<T_1 extends quat2>(out: T_1, a: ReadonlyQuat2, b: ReadonlyQuat2, t: number): Quat2Result<T_1>;
     /**
      * Calculates the inverse of a dual quat. If they are normalized, conjugate is cheaper
      *
-     * @param {quat2} out the receiving dual quaternion
+     * @template {quat2} T
+     * @param {T} out the receiving dual quaternion
      * @param {ReadonlyQuat2} a dual quat to calculate inverse of
-     * @returns {quat2} out
+     * @returns {Quat2Result<T>} out
      */
-    export function invert(out: quat2, a: ReadonlyQuat2): quat2;
+    export function invert<T_1 extends quat2>(out: T_1, a: ReadonlyQuat2): Quat2Result<T_1>;
     /**
      * Calculates the conjugate of a dual quat
      * If the dual quaternion is normalized, this function is faster than quat2.inverse and produces the same result.
      *
-     * @param {quat2} out the receiving quaternion
+     * @template {quat2} T
+     * @param {T} out the receiving quaternion
      * @param {ReadonlyQuat2} a quat to calculate conjugate of
-     * @returns {quat2} out
+     * @returns {Quat2Result<T>} out
      */
-    export function conjugate(out: quat2, a: ReadonlyQuat2): quat2;
+    export function conjugate<T_1 extends quat2>(out: T_1, a: ReadonlyQuat2): Quat2Result<T_1>;
     /**
      * Normalize a dual quat
      *
-     * @param {quat2} out the receiving dual quaternion
+     * @template {quat2} T
+     * @param {T} out the receiving dual quaternion
      * @param {ReadonlyQuat2} a dual quaternion to normalize
-     * @returns {quat2} out
+     * @returns {Quat2Result<T>} out
      * @function
      */
-    export function normalize(out: quat2, a: ReadonlyQuat2): quat2;
+    export function normalize<T_1 extends quat2>(out: T_1, a: ReadonlyQuat2): Quat2Result<T_1>;
     /**
      * Returns a string representation of a dual quaternion
      *
@@ -2886,21 +3143,23 @@ export namespace quat2 {
     /**
      * Set the real component of a dual quat to the given quaternion
      *
-     * @param {quat2} out the receiving quaternion
+     * @template {quat2} T
+     * @param {T} out the receiving quaternion
      * @param {ReadonlyQuat} q a quaternion representing the real part
-     * @returns {quat2} out
+     * @returns {Quat2Result<T>} out
      * @function
      */
     export const setReal: typeof vec4.copy;
     /**
      * Multiplies two dual quat's
      *
-     * @param {quat2} out the receiving dual quaternion
+     * @template {quat2} T
+     * @param {T} out the receiving dual quaternion
      * @param {ReadonlyQuat2} a the first operand
      * @param {ReadonlyQuat2} b the second operand
-     * @returns {quat2} out
+     * @returns {Quat2Result<T>} out
      */
-    export function mul(out: quat2, a: ReadonlyQuat2, b: ReadonlyQuat2): quat2;
+    export function mul<T_1 extends quat2>(out: T_1, a: ReadonlyQuat2, b: ReadonlyQuat2): Quat2Result<T_1>;
     /**
      * Calculates the dot product of two dual quat's (The dot product of the real parts)
      *
@@ -2945,138 +3204,151 @@ export namespace vec2 {
     /**
      * Creates a new, empty vec2
      *
-     * @returns {vec2} a new 2D vector
+     * @returns {vec2<DefaultArrayType>} a new 2D vector
      */
-    export function create(): vec2;
+    export function create(): vec2<DefaultArrayType>;
     /**
      * Creates a new vec2 initialized with values from an existing vector
      *
      * @param {ReadonlyVec2} a vector to clone
-     * @returns {vec2} a new 2D vector
+     * @returns {vec2<DefaultArrayType>} a new 2D vector
      */
-    export function clone(a: ReadonlyVec2): vec2;
+    export function clone(a: ReadonlyVec2): vec2<DefaultArrayType>;
     /**
      * Creates a new vec2 initialized with the given values
      *
      * @param {Number} x X component
      * @param {Number} y Y component
-     * @returns {vec2} a new 2D vector
+     * @returns {vec2<DefaultArrayType>} a new 2D vector
      */
-    export function fromValues(x: number, y: number): vec2;
+    export function fromValues(x: number, y: number): vec2<DefaultArrayType>;
     /**
      * Copy the values from one vec2 to another
      *
-     * @param {vec2} out the receiving vector
+     * @template {vec2} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyVec2} a the source vector
-     * @returns {vec2} out
+     * @returns {Vec2Result<T>} out
      */
-    export function copy(out: vec2, a: ReadonlyVec2): vec2;
+    export function copy<T extends vec2>(out: T, a: ReadonlyVec2): Vec2Result<T>;
     /**
      * Set the components of a vec2 to the given values
      *
-     * @param {vec2} out the receiving vector
+     * @template {vec2} T
+     * @param {T} out the receiving vector
      * @param {Number} x X component
      * @param {Number} y Y component
-     * @returns {vec2} out
+     * @returns {Vec2Result<T>} out
      */
-    export function set(out: vec2, x: number, y: number): vec2;
+    export function set<T extends vec2>(out: T, x: number, y: number): Vec2Result<T>;
     /**
      * Adds two vec2's
      *
-     * @param {vec2} out the receiving vector
+     * @template {vec2} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyVec2} a the first operand
      * @param {ReadonlyVec2} b the second operand
-     * @returns {vec2} out
+     * @returns {Vec2Result<T>} out
      */
-    export function add(out: vec2, a: ReadonlyVec2, b: ReadonlyVec2): vec2;
+    export function add<T extends vec2>(out: T, a: ReadonlyVec2, b: ReadonlyVec2): Vec2Result<T>;
     /**
      * Subtracts vector b from vector a
      *
-     * @param {vec2} out the receiving vector
+     * @template {vec2} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyVec2} a the first operand
      * @param {ReadonlyVec2} b the second operand
-     * @returns {vec2} out
+     * @returns {Vec2Result<T>} out
      */
-    export function subtract(out: vec2, a: ReadonlyVec2, b: ReadonlyVec2): vec2;
+    export function subtract<T extends vec2>(out: T, a: ReadonlyVec2, b: ReadonlyVec2): Vec2Result<T>;
     /**
      * Multiplies two vec2's
      *
-     * @param {vec2} out the receiving vector
+     * @template {vec2} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyVec2} a the first operand
      * @param {ReadonlyVec2} b the second operand
-     * @returns {vec2} out
+     * @returns {Vec2Result<T>} out
      */
-    export function multiply(out: vec2, a: ReadonlyVec2, b: ReadonlyVec2): vec2;
+    export function multiply<T extends vec2>(out: T, a: ReadonlyVec2, b: ReadonlyVec2): Vec2Result<T>;
     /**
      * Divides two vec2's
      *
-     * @param {vec2} out the receiving vector
+     * @template {vec2} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyVec2} a the first operand
      * @param {ReadonlyVec2} b the second operand
-     * @returns {vec2} out
+     * @returns {Vec2Result<T>} out
      */
-    export function divide(out: vec2, a: ReadonlyVec2, b: ReadonlyVec2): vec2;
+    export function divide<T extends vec2>(out: T, a: ReadonlyVec2, b: ReadonlyVec2): Vec2Result<T>;
     /**
      * Math.ceil the components of a vec2
      *
-     * @param {vec2} out the receiving vector
+     * @template {vec2} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyVec2} a vector to ceil
-     * @returns {vec2} out
+     * @returns {Vec2Result<T>} out
      */
-    export function ceil(out: vec2, a: ReadonlyVec2): vec2;
+    export function ceil<T extends vec2>(out: T, a: ReadonlyVec2): Vec2Result<T>;
     /**
      * Math.floor the components of a vec2
      *
-     * @param {vec2} out the receiving vector
+     * @template {vec2} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyVec2} a vector to floor
-     * @returns {vec2} out
+     * @returns {Vec2Result<T>} out
      */
-    export function floor(out: vec2, a: ReadonlyVec2): vec2;
+    export function floor<T extends vec2>(out: T, a: ReadonlyVec2): Vec2Result<T>;
     /**
      * Returns the minimum of two vec2's
      *
-     * @param {vec2} out the receiving vector
+     * @template {vec2} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyVec2} a the first operand
      * @param {ReadonlyVec2} b the second operand
-     * @returns {vec2} out
+     * @returns {Vec2Result<T>} out
      */
-    export function min(out: vec2, a: ReadonlyVec2, b: ReadonlyVec2): vec2;
+    export function min<T extends vec2>(out: T, a: ReadonlyVec2, b: ReadonlyVec2): Vec2Result<T>;
     /**
      * Returns the maximum of two vec2's
      *
-     * @param {vec2} out the receiving vector
+     * @template {vec2} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyVec2} a the first operand
      * @param {ReadonlyVec2} b the second operand
-     * @returns {vec2} out
+     * @returns {Vec2Result<T>} out
      */
-    export function max(out: vec2, a: ReadonlyVec2, b: ReadonlyVec2): vec2;
+    export function max<T extends vec2>(out: T, a: ReadonlyVec2, b: ReadonlyVec2): Vec2Result<T>;
     /**
      * symmetric round the components of a vec2
      *
-     * @param {vec2} out the receiving vector
+     * @template {vec2} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyVec2} a vector to round
-     * @returns {vec2} out
+     * @returns {Vec2Result<T>} out
      */
-    export function round(out: vec2, a: ReadonlyVec2): vec2;
+    export function round<T extends vec2>(out: T, a: ReadonlyVec2): Vec2Result<T>;
     /**
      * Scales a vec2 by a scalar number
      *
-     * @param {vec2} out the receiving vector
+     * @template {vec2} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyVec2} a the vector to scale
      * @param {Number} b amount to scale the vector by
-     * @returns {vec2} out
+     * @returns {Vec2Result<T>} out
      */
-    export function scale(out: vec2, a: ReadonlyVec2, b: number): vec2;
+    export function scale<T extends vec2>(out: T, a: ReadonlyVec2, b: number): Vec2Result<T>;
     /**
      * Adds two vec2's after scaling the second operand by a scalar value
      *
-     * @param {vec2} out the receiving vector
+     * @template {vec2} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyVec2} a the first operand
      * @param {ReadonlyVec2} b the second operand
      * @param {Number} scale the amount to scale b by before adding
-     * @returns {vec2} out
+     * @returns {Vec2Result<T>} out
      */
-    export function scaleAndAdd(out: vec2, a: ReadonlyVec2, b: ReadonlyVec2, scale: number): vec2;
+    export function scaleAndAdd<T extends vec2>(out: T, a: ReadonlyVec2, b: ReadonlyVec2, scale: number): Vec2Result<T>;
     /**
      * Calculates the euclidian distance between two vec2's
      *
@@ -3110,27 +3382,30 @@ export namespace vec2 {
     /**
      * Negates the components of a vec2
      *
-     * @param {vec2} out the receiving vector
+     * @template {vec2} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyVec2} a vector to negate
-     * @returns {vec2} out
+     * @returns {Vec2Result<T>} out
      */
-    export function negate(out: vec2, a: ReadonlyVec2): vec2;
+    export function negate<T extends vec2>(out: T, a: ReadonlyVec2): Vec2Result<T>;
     /**
      * Returns the inverse of the components of a vec2
      *
-     * @param {vec2} out the receiving vector
+     * @template {vec2} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyVec2} a vector to invert
-     * @returns {vec2} out
+     * @returns {Vec2Result<T>} out
      */
-    export function inverse(out: vec2, a: ReadonlyVec2): vec2;
+    export function inverse<T extends vec2>(out: T, a: ReadonlyVec2): Vec2Result<T>;
     /**
      * Normalize a vec2
      *
-     * @param {vec2} out the receiving vector
+     * @template {vec2} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyVec2} a vector to normalize
-     * @returns {vec2} out
+     * @returns {Vec2Result<T>} out
      */
-    export function normalize(out: vec2, a: ReadonlyVec2): vec2;
+    export function normalize<T extends vec2>(out: T, a: ReadonlyVec2): Vec2Result<T>;
     /**
      * Calculates the dot product of two vec2's
      *
@@ -3143,78 +3418,86 @@ export namespace vec2 {
      * Computes the cross product of two vec2's
      * Note that the cross product must by definition produce a 3D vector
      *
-     * @param {vec3} out the receiving vector
+     * @template {vec3} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyVec2} a the first operand
      * @param {ReadonlyVec2} b the second operand
-     * @returns {vec3} out
+     * @returns {Vec2Result<T>} out
      */
-    export function cross(out: vec3, a: ReadonlyVec2, b: ReadonlyVec2): vec3;
+    export function cross<T extends vec3>(out: T, a: ReadonlyVec2, b: ReadonlyVec2): Vec2Result<T>;
     /**
      * Performs a linear interpolation between two vec2's
      *
-     * @param {vec2} out the receiving vector
+     * @template {vec2} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyVec2} a the first operand
      * @param {ReadonlyVec2} b the second operand
      * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
-     * @returns {vec2} out
+     * @returns {Vec2Result<T>} out
      */
-    export function lerp(out: vec2, a: ReadonlyVec2, b: ReadonlyVec2, t: number): vec2;
+    export function lerp<T extends vec2>(out: T, a: ReadonlyVec2, b: ReadonlyVec2, t: number): Vec2Result<T>;
     /**
      * Generates a random vector with the given scale
      *
-     * @param {vec2} out the receiving vector
+     * @template {vec2} T
+     * @param {T} out the receiving vector
      * @param {Number} [scale] Length of the resulting vector. If omitted, a unit vector will be returned
-     * @returns {vec2} out
+     * @returns {Vec2Result<T>} out
      */
-    export function random(out: vec2, scale?: number): vec2;
+    export function random<T extends vec2>(out: T, scale?: number): Vec2Result<T>;
     /**
      * Transforms the vec2 with a mat2
      *
-     * @param {vec2} out the receiving vector
+     * @template {vec2} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyVec2} a the vector to transform
      * @param {ReadonlyMat2} m matrix to transform with
-     * @returns {vec2} out
+     * @returns {Vec2Result<T>} out
      */
-    export function transformMat2(out: vec2, a: ReadonlyVec2, m: ReadonlyMat2): vec2;
+    export function transformMat2<T extends vec2>(out: T, a: ReadonlyVec2, m: ReadonlyMat2): Vec2Result<T>;
     /**
      * Transforms the vec2 with a mat2d
      *
-     * @param {vec2} out the receiving vector
+     * @template {vec2} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyVec2} a the vector to transform
      * @param {ReadonlyMat2d} m matrix to transform with
-     * @returns {vec2} out
+     * @returns {Vec2Result<T>} out
      */
-    export function transformMat2d(out: vec2, a: ReadonlyVec2, m: ReadonlyMat2d): vec2;
+    export function transformMat2d<T extends vec2>(out: T, a: ReadonlyVec2, m: ReadonlyMat2d): Vec2Result<T>;
     /**
      * Transforms the vec2 with a mat3
      * 3rd vector component is implicitly '1'
      *
-     * @param {vec2} out the receiving vector
+     * @template {vec2} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyVec2} a the vector to transform
      * @param {ReadonlyMat3} m matrix to transform with
-     * @returns {vec2} out
+     * @returns {Vec2Result<T>} out
      */
-    export function transformMat3(out: vec2, a: ReadonlyVec2, m: ReadonlyMat3): vec2;
+    export function transformMat3<T extends vec2>(out: T, a: ReadonlyVec2, m: ReadonlyMat3): Vec2Result<T>;
     /**
      * Transforms the vec2 with a mat4
      * 3rd vector component is implicitly '0'
      * 4th vector component is implicitly '1'
      *
-     * @param {vec2} out the receiving vector
+     * @template {vec2} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyVec2} a the vector to transform
      * @param {ReadonlyMat4} m matrix to transform with
-     * @returns {vec2} out
+     * @returns {Vec2Result<T>} out
      */
-    export function transformMat4(out: vec2, a: ReadonlyVec2, m: ReadonlyMat4): vec2;
+    export function transformMat4<T extends vec2>(out: T, a: ReadonlyVec2, m: ReadonlyMat4): Vec2Result<T>;
     /**
      * Rotate a 2D vector
-     * @param {vec2} out The receiving vec2
+     * @template {vec2} T
+     * @param {T} out The receiving vec2
      * @param {ReadonlyVec2} a The vec2 point to rotate
      * @param {ReadonlyVec2} b The origin of the rotation
      * @param {Number} rad The angle of rotation in radians
-     * @returns {vec2} out
+     * @returns {Vec2Result<T>} out
      */
-    export function rotate(out: vec2, a: ReadonlyVec2, b: ReadonlyVec2, rad: number): vec2;
+    export function rotate<T extends vec2>(out: T, a: ReadonlyVec2, b: ReadonlyVec2, rad: number): Vec2Result<T>;
     /**
      * Get the smallest angle between two 2D vectors
      * @param {ReadonlyVec2} a The first operand
@@ -3233,10 +3516,11 @@ export namespace vec2 {
     /**
      * Set the components of a vec2 to zero
      *
-     * @param {vec2} out the receiving vector
-     * @returns {vec2} out
+     * @template {vec2} T
+     * @param {T} out the receiving vector
+     * @returns {Vec2Result<T>} out
      */
-    export function zero(out: vec2): vec2;
+    export function zero<T extends vec2>(out: T): Vec2Result<T>;
     /**
      * Returns a string representation of a vector
      *
@@ -3270,30 +3554,33 @@ export namespace vec2 {
     /**
      * Subtracts vector b from vector a
      *
-     * @param {vec2} out the receiving vector
+     * @template {vec2} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyVec2} a the first operand
      * @param {ReadonlyVec2} b the second operand
-     * @returns {vec2} out
+     * @returns {Vec2Result<T>} out
      */
-    export function sub(out: vec2, a: ReadonlyVec2, b: ReadonlyVec2): vec2;
+    export function sub<T extends vec2>(out: T, a: ReadonlyVec2, b: ReadonlyVec2): Vec2Result<T>;
     /**
      * Multiplies two vec2's
      *
-     * @param {vec2} out the receiving vector
+     * @template {vec2} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyVec2} a the first operand
      * @param {ReadonlyVec2} b the second operand
-     * @returns {vec2} out
+     * @returns {Vec2Result<T>} out
      */
-    export function mul(out: vec2, a: ReadonlyVec2, b: ReadonlyVec2): vec2;
+    export function mul<T extends vec2>(out: T, a: ReadonlyVec2, b: ReadonlyVec2): Vec2Result<T>;
     /**
      * Divides two vec2's
      *
-     * @param {vec2} out the receiving vector
+     * @template {vec2} T
+     * @param {T} out the receiving vector
      * @param {ReadonlyVec2} a the first operand
      * @param {ReadonlyVec2} b the second operand
-     * @returns {vec2} out
+     * @returns {Vec2Result<T>} out
      */
-    export function div(out: vec2, a: ReadonlyVec2, b: ReadonlyVec2): vec2;
+    export function div<T extends vec2>(out: T, a: ReadonlyVec2, b: ReadonlyVec2): Vec2Result<T>;
     /**
      * Calculates the euclidian distance between two vec2's
      *
